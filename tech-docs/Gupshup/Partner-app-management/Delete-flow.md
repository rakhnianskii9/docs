# Gupshup Partner API - Delete Flow

## Overview
The Delete Flow API allows you to permanently delete a flow from your application. This endpoint can only be used to delete flows that are in DRAFT state. Published flows cannot be deleted and must be deprecated instead.

## Endpoint Details

**URL:** `https://partner.gupshup.io/partner/app/{appId}/flow/{flowId}`  
**Method:** `DELETE`  
**Content-Type:** `application/json`

## Request Parameters

| Parameter | Description | Example | Type | Required | Notes |
|-----------|-------------|---------|------|----------|-------|
| Authorization | Access Token for the application | `{{PARTNER_APP_TOKEN}}` | String | Required | Should be a valid Partner App Access Token |
| appId | App ID to fetch the access token | `{{APP_ID}}` | String | Required | The Id should be a valid app Id of Gupshup |
| flowId | Flow Id | `{{FLOW_ID}}` | String | Required | Flow ID generated by Meta |

## Sample cURL Request

```bash
curl --location --request DELETE 'https://partner.gupshup.io/partner/app/{{APP_ID}}/flow/{{FLOW_ID}}' \
--header 'Authorization: {{PARTNER_APP_TOKEN}}' \
--header 'Content-Type: application/json'
```

## Sample Response

### Success Response
```json
{
    "status": "success",
    "success": true
}
```

## Status Codes

| Code | Response | Description |
|------|----------|-------------|
| 200 | `{ "status": "success", "success": true }` | Successfully delete a flow |
| 400 | `{ "status": "error", "message": "After a flow has been published, it cannot be deleted. Please deprecate instead" }` | For deleting a published flow |

## Node.js Code Examples

### Basic Flow Deletion

```javascript
const axios = require('axios');

async function deleteFlow(appId, flowId, token) {
    try {
        const response = await axios.delete(
            `https://partner.gupshup.io/partner/app/${appId}/flow/${flowId}`,
            {
                headers: {
                    'Authorization': token,
                    'Content-Type': 'application/json'
                }
            }
        );
        
        return response.data;
    } catch (error) {
        console.error('Error deleting flow:', error.response?.data || error.message);
        throw error;
    }
}

// Usage
const appId = 'your-app-id';
const flowId = 'your-flow-id';
const token = 'your-partner-token';

deleteFlow(appId, flowId, token)
    .then(result => {
        console.log('Flow deleted successfully:', result);
    })
    .catch(error => {
        console.error('Failed to delete flow:', error);
    });
```

### With Enhanced Error Handling

```javascript
const axios = require('axios');

async function deleteFlowWithErrorHandling(appId, flowId, token) {
    try {
        const response = await axios.delete(
            `https://partner.gupshup.io/partner/app/${appId}/flow/${flowId}`,
            {
                headers: {
                    'Authorization': token,
                    'Content-Type': 'application/json'
                },
                timeout: 10000 // 10 seconds timeout
            }
        );
        
        if (response.data.success) {
            return {
                success: true,
                message: 'Flow deleted successfully',
                data: response.data
            };
        } else {
            return {
                success: false,
                message: 'Failed to delete flow',
                error: response.data
            };
        }
    } catch (error) {
        if (error.response) {
            // Server responded with error status
            const errorMessage = error.response.data?.message || 'Unknown server error';
            return {
                success: false,
                message: errorMessage,
                statusCode: error.response.status,
                error: error.response.data
            };
        } else if (error.request) {
            // Request was made but no response received
            return {
                success: false,
                message: 'No response received from server',
                error: 'Network error'
            };
        } else {
            // Something else happened
            return {
                success: false,
                message: 'Request setup error',
                error: error.message
            };
        }
    }
}

// Usage
deleteFlowWithErrorHandling(appId, flowId, token)
    .then(result => {
        if (result.success) {
            console.log('✅ Flow deleted successfully:', result.data);
        } else {
            console.error('❌ Failed to delete flow:', result.message);
        }
    });
```

### Complete Flow Deletion Manager

```javascript
const axios = require('axios');

class FlowDeletionManager {
    constructor(baseURL = 'https://partner.gupshup.io/partner', timeout = 10000) {
        this.baseURL = baseURL;
        this.timeout = timeout;
        this.axiosInstance = axios.create({
            baseURL: this.baseURL,
            timeout: this.timeout,
            headers: {
                'Content-Type': 'application/json'
            }
        });
    }

    async deleteFlow(appId, flowId, token) {
        try {
            const response = await this.axiosInstance.delete(
                `/app/${appId}/flow/${flowId}`,
                {
                    headers: {
                        'Authorization': token
                    }
                }
            );
            
            return {
                success: true,
                data: response.data,
                timestamp: new Date().toISOString()
            };
        } catch (error) {
            throw this.handleError(error);
        }
    }

    async deleteFlowWithValidation(appId, flowId, token) {
        // Validate input parameters
        if (!appId || !flowId || !token) {
            throw new Error('Missing required parameters: appId, flowId, and token are required');
        }

        try {
            // Check if flow can be deleted (optional validation)
            const canDelete = await this.canFlowBeDeleted(appId, flowId, token);
            if (!canDelete) {
                throw new Error('Flow cannot be deleted - it may be published or in use');
            }

            const result = await this.deleteFlow(appId, flowId, token);
            
            // Log successful deletion
            this.logActivity('DELETE_SUCCESS', {
                appId,
                flowId,
                timestamp: result.timestamp
            });
            
            return result;
        } catch (error) {
            // Log failed deletion
            this.logActivity('DELETE_FAILED', {
                appId,
                flowId,
                error: error.message,
                timestamp: new Date().toISOString()
            });
            
            throw error;
        }
    }

    async deleteFlowWithConfirmation(appId, flowId, token, confirmationCallback) {
        try {
            // Get flow details before deletion (if available)
            const flowDetails = await this.getFlowDetails(appId, flowId, token);
            
            // Ask for confirmation
            const confirmed = await confirmationCallback(flowDetails);
            
            if (!confirmed) {
                return {
                    success: false,
                    message: 'Deletion cancelled by user',
                    cancelled: true
                };
            }
            
            // Proceed with deletion
            const result = await this.deleteFlow(appId, flowId, token);
            
            return {
                ...result,
                confirmed: true
            };
        } catch (error) {
            throw error;
        }
    }

    async deleteMultipleFlows(appId, flowIds, token) {
        const results = [];
        
        for (const flowId of flowIds) {
            try {
                const result = await this.deleteFlow(appId, flowId, token);
                results.push({
                    flowId,
                    success: true,
                    result: result.data
                });
            } catch (error) {
                results.push({
                    flowId,
                    success: false,
                    error: error.message
                });
            }
        }
        
        return results;
    }

    async deleteFlowWithRetry(appId, flowId, token, maxRetries = 3) {
        let lastError;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const result = await this.deleteFlow(appId, flowId, token);
                
                if (attempt > 1) {
                    console.log(`✅ Flow deleted successfully on attempt ${attempt}`);
                }
                
                return result;
            } catch (error) {
                lastError = error;
                
                if (attempt < maxRetries) {
                    const delay = Math.pow(2, attempt) * 1000; // Exponential backoff
                    console.log(`❌ Attempt ${attempt} failed, retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                } else {
                    console.log(`❌ All ${maxRetries} attempts failed`);
                }
            }
        }
        
        throw lastError;
    }

    async safeDeleteFlow(appId, flowId, token) {
        try {
            // First, try to get flow details to check status
            const flowDetails = await this.getFlowDetails(appId, flowId, token);
            
            if (flowDetails.status === 'PUBLISHED') {
                return {
                    success: false,
                    message: 'Cannot delete published flow. Use deprecate instead.',
                    suggestedAction: 'deprecate',
                    flowDetails
                };
            }
            
            // If flow is in draft state, proceed with deletion
            const result = await this.deleteFlow(appId, flowId, token);
            
            return {
                ...result,
                flowDetails
            };
        } catch (error) {
            // If we can't get flow details, try deletion anyway
            if (error.message.includes('not found')) {
                try {
                    return await this.deleteFlow(appId, flowId, token);
                } catch (deleteError) {
                    throw deleteError;
                }
            }
            throw error;
        }
    }

    async getFlowDetails(appId, flowId, token) {
        try {
            // This would require implementing the get flow details API
            // For now, we'll return a placeholder
            return {
                flowId,
                appId,
                status: 'DRAFT',
                name: 'Flow Name'
            };
        } catch (error) {
            console.warn('Could not fetch flow details:', error.message);
            return { flowId, appId, status: 'UNKNOWN' };
        }
    }

    async canFlowBeDeleted(appId, flowId, token) {
        try {
            const flowDetails = await this.getFlowDetails(appId, flowId, token);
            return flowDetails.status === 'DRAFT';
        } catch (error) {
            console.warn('Could not verify flow status:', error.message);
            return true; // Allow deletion attempt if we can't verify
        }
    }

    handleError(error) {
        if (error.response) {
            const { status, data } = error.response;
            
            switch (status) {
                case 400:
                    return new Error(data.message || 'Flow cannot be deleted - it may be published');
                case 401:
                    return new Error('Unauthorized - Invalid or expired token');
                case 403:
                    return new Error('Forbidden - Insufficient permissions');
                case 404:
                    return new Error('Flow not found');
                case 409:
                    return new Error('Conflict - Flow may be in use or published');
                case 429:
                    return new Error('Rate limit exceeded');
                case 500:
                    return new Error('Internal server error');
                default:
                    return new Error(`HTTP ${status}: ${data.message || 'Unknown error'}`);
            }
        } else if (error.request) {
            return new Error('Network error - No response received');
        } else {
            return new Error(`Request error: ${error.message}`);
        }
    }

    logActivity(action, details) {
        const logEntry = {
            action,
            timestamp: new Date().toISOString(),
            ...details
        };
        
        console.log(`[${action}]`, logEntry);
        
        // You can extend this to write to a file, database, or external logging service
    }
}

// Usage Examples
const flowManager = new FlowDeletionManager();

// Basic usage
async function example1() {
    const appId = 'your-app-id';
    const flowId = 'your-flow-id';
    const token = 'your-partner-token';
    
    try {
        const result = await flowManager.deleteFlow(appId, flowId, token);
        console.log('Flow deleted:', result);
    } catch (error) {
        console.error('Error:', error.message);
    }
}

// With validation
async function example2() {
    const appId = 'your-app-id';
    const flowId = 'your-flow-id';
    const token = 'your-partner-token';
    
    try {
        const result = await flowManager.deleteFlowWithValidation(appId, flowId, token);
        console.log('Flow deleted with validation:', result);
    } catch (error) {
        console.error('Validation error:', error.message);
    }
}

// Safe deletion with status check
async function example3() {
    const appId = 'your-app-id';
    const flowId = 'your-flow-id';
    const token = 'your-partner-token';
    
    try {
        const result = await flowManager.safeDeleteFlow(appId, flowId, token);
        
        if (result.success) {
            console.log('Flow deleted safely:', result);
        } else {
            console.log('Cannot delete flow:', result.message);
            if (result.suggestedAction === 'deprecate') {
                console.log('Consider using the deprecate API instead');
            }
        }
    } catch (error) {
        console.error('Safe deletion error:', error.message);
    }
}

// Delete multiple flows
async function example4() {
    const appId = 'your-app-id';
    const flowIds = ['flow1', 'flow2', 'flow3'];
    const token = 'your-partner-token';
    
    try {
        const results = await flowManager.deleteMultipleFlows(appId, flowIds, token);
        console.log('Multiple flows deleted:', results);
    } catch (error) {
        console.error('Error:', error.message);
    }
}

// With confirmation
async function example5() {
    const appId = 'your-app-id';
    const flowId = 'your-flow-id';
    const token = 'your-partner-token';
    
    const confirmationCallback = async (flowDetails) => {
        console.log('About to delete flow:', flowDetails);
        // In a real application, you might show a confirmation dialog
        return true; // or false to cancel
    };
    
    try {
        const result = await flowManager.deleteFlowWithConfirmation(
            appId, 
            flowId, 
            token, 
            confirmationCallback
        );
        
        if (result.cancelled) {
            console.log('Deletion cancelled by user');
        } else {
            console.log('Flow deleted with confirmation:', result);
        }
    } catch (error) {
        console.error('Error:', error.message);
    }
}
```

### Integration with Flow Cleanup Pipeline

```javascript
// Advanced flow deletion with cleanup pipeline
class FlowCleanupManager {
    constructor(deletionManager) {
        this.deletionManager = deletionManager;
        this.cleanupQueue = [];
        this.cleanupHistory = [];
    }

    async scheduleFlowCleanup(appId, flowId, token, options = {}) {
        const {
            delay = 0,
            reason = 'Scheduled cleanup',
            backupBeforeDelete = true,
            notifyOnCompletion = true
        } = options;

        const cleanupItem = {
            id: `cleanup-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            appId,
            flowId,
            token,
            reason,
            backupBeforeDelete,
            notifyOnCompletion,
            scheduledAt: new Date().toISOString(),
            executeAt: new Date(Date.now() + delay).toISOString(),
            status: 'SCHEDULED'
        };

        this.cleanupQueue.push(cleanupItem);
        
        if (delay > 0) {
            setTimeout(() => {
                this.executeCleanup(cleanupItem.id);
            }, delay);
        } else {
            // Execute immediately
            this.executeCleanup(cleanupItem.id);
        }

        return cleanupItem.id;
    }

    async executeCleanup(cleanupId) {
        const cleanupItem = this.cleanupQueue.find(item => item.id === cleanupId);
        if (!cleanupItem) {
            console.error('Cleanup item not found:', cleanupId);
            return;
        }

        try {
            cleanupItem.status = 'EXECUTING';
            cleanupItem.startedAt = new Date().toISOString();

            // Backup flow data if requested
            if (cleanupItem.backupBeforeDelete) {
                await this.backupFlowData(cleanupItem);
            }

            // Execute deletion
            const result = await this.deletionManager.deleteFlow(
                cleanupItem.appId,
                cleanupItem.flowId,
                cleanupItem.token
            );

            cleanupItem.status = 'COMPLETED';
            cleanupItem.completedAt = new Date().toISOString();
            cleanupItem.result = result;

            // Move to history
            this.cleanupHistory.push(cleanupItem);
            this.cleanupQueue = this.cleanupQueue.filter(item => item.id !== cleanupId);

            // Notify if requested
            if (cleanupItem.notifyOnCompletion) {
                await this.notifyCleanupCompletion(cleanupItem);
            }

            console.log(`✅ Cleanup completed for flow ${cleanupItem.flowId}`);

        } catch (error) {
            cleanupItem.status = 'FAILED';
            cleanupItem.error = error.message;
            cleanupItem.failedAt = new Date().toISOString();

            console.error(`❌ Cleanup failed for flow ${cleanupItem.flowId}:`, error.message);

            // Move to history even if failed
            this.cleanupHistory.push(cleanupItem);
            this.cleanupQueue = this.cleanupQueue.filter(item => item.id !== cleanupId);
        }
    }

    async backupFlowData(cleanupItem) {
        try {
            // In a real implementation, you would backup flow data
            console.log(`Backing up flow data for ${cleanupItem.flowId}`);
            
            const backupData = {
                flowId: cleanupItem.flowId,
                appId: cleanupItem.appId,
                backupTimestamp: new Date().toISOString(),
                reason: cleanupItem.reason
            };

            // Store backup (file, database, cloud storage, etc.)
            cleanupItem.backupLocation = `backup/${cleanupItem.flowId}-${Date.now()}.json`;
            
            return backupData;
        } catch (error) {
            console.warn('Failed to backup flow data:', error.message);
            throw error;
        }
    }

    async notifyCleanupCompletion(cleanupItem) {
        const notification = {
            type: 'FLOW_CLEANUP_COMPLETED',
            flowId: cleanupItem.flowId,
            appId: cleanupItem.appId,
            status: cleanupItem.status,
            completedAt: cleanupItem.completedAt,
            reason: cleanupItem.reason
        };

        console.log('Cleanup notification:', notification);
        // Send notification through your preferred channel
    }

    async bulkFlowCleanup(appId, flowIds, token, options = {}) {
        const cleanupIds = [];
        
        for (const flowId of flowIds) {
            const cleanupId = await this.scheduleFlowCleanup(appId, flowId, token, options);
            cleanupIds.push(cleanupId);
        }
        
        return cleanupIds;
    }

    getCleanupStatus(cleanupId = null) {
        if (cleanupId) {
            const queueItem = this.cleanupQueue.find(item => item.id === cleanupId);
            const historyItem = this.cleanupHistory.find(item => item.id === cleanupId);
            return queueItem || historyItem || null;
        }
        
        return {
            queue: this.cleanupQueue.length,
            completed: this.cleanupHistory.filter(item => item.status === 'COMPLETED').length,
            failed: this.cleanupHistory.filter(item => item.status === 'FAILED').length,
            total: this.cleanupQueue.length + this.cleanupHistory.length
        };
    }

    async cancelCleanup(cleanupId) {
        const cleanupItem = this.cleanupQueue.find(item => item.id === cleanupId);
        if (!cleanupItem) {
            throw new Error('Cleanup item not found or already executed');
        }

        if (cleanupItem.status === 'EXECUTING') {
            throw new Error('Cannot cancel cleanup that is currently executing');
        }

        cleanupItem.status = 'CANCELLED';
        cleanupItem.cancelledAt = new Date().toISOString();

        // Move to history
        this.cleanupHistory.push(cleanupItem);
        this.cleanupQueue = this.cleanupQueue.filter(item => item.id !== cleanupId);

        return cleanupItem;
    }
}

// Usage
const deletionManager = new FlowDeletionManager();
const cleanupManager = new FlowCleanupManager(deletionManager);

// Schedule cleanup
async function cleanupExample() {
    const appId = 'your-app-id';
    const flowId = 'your-flow-id';
    const token = 'your-partner-token';
    
    try {
        const cleanupId = await cleanupManager.scheduleFlowCleanup(
            appId,
            flowId,
            token,
            {
                delay: 5000, // 5 seconds delay
                reason: 'Development cleanup',
                backupBeforeDelete: true,
                notifyOnCompletion: true
            }
        );
        
        console.log('Cleanup scheduled:', cleanupId);
        
        // Check status later
        setTimeout(() => {
            const status = cleanupManager.getCleanupStatus(cleanupId);
            console.log('Cleanup status:', status);
        }, 6000);
        
    } catch (error) {
        console.error('Cleanup scheduling error:', error.message);
    }
}

// Bulk cleanup
async function bulkCleanupExample() {
    const appId = 'your-app-id';
    const flowIds = ['draft-flow-1', 'draft-flow-2', 'draft-flow-3'];
    const token = 'your-partner-token';
    
    try {
        const cleanupIds = await cleanupManager.bulkFlowCleanup(
            appId,
            flowIds,
            token,
            {
                delay: 1000, // 1 second delay between cleanups
                reason: 'Bulk cleanup of draft flows',
                backupBeforeDelete: true
            }
        );
        
        console.log('Bulk cleanup scheduled:', cleanupIds);
        
        // Monitor overall status
        const overallStatus = cleanupManager.getCleanupStatus();
        console.log('Overall cleanup status:', overallStatus);
        
    } catch (error) {
        console.error('Bulk cleanup error:', error.message);
    }
}
```

## Best Practices

### 1. Flow State Validation
- Always verify that the flow is in DRAFT state before attempting to delete
- Published flows cannot be deleted and must be deprecated instead
- Use the safe deletion approach to check flow status first

### 2. Confirmation and Safety
- Always implement confirmation dialogs for deletion operations
- Consider implementing a "soft delete" or backup mechanism
- Provide clear warnings about the irreversible nature of deletion

### 3. Error Handling
- Handle the specific error when trying to delete published flows
- Provide clear guidance on using deprecate API for published flows
- Implement proper retry logic for transient failures

### 4. Monitoring and Logging
- Log all deletion attempts and their outcomes
- Track deletion patterns and reasons
- Monitor the impact of deletions on the application

### 5. Cleanup Management
- Implement scheduled cleanup for draft flows
- Use batch operations carefully to avoid rate limiting
- Consider implementing cleanup pipelines for systematic flow management

## Common Use Cases

1. **Draft Cleanup**: Remove abandoned or test flows in draft state
2. **Development Cleanup**: Clean up flows created during development
3. **Batch Cleanup**: Remove multiple obsolete draft flows
4. **Error Recovery**: Delete flows that failed during creation
5. **Resource Management**: Clean up flows to manage storage and quotas

## Important Notes

- **Only draft flows can be deleted** - Published flows must be deprecated
- **Deletion is permanent** - There is no recovery mechanism through the API
- **Consider backup** - Always backup important flow data before deletion
- **Rate limiting** - Be mindful of API rate limits when deleting multiple flows
- **Dependencies** - Check for any dependencies before deleting flows

## Error Handling Examples

```javascript
// Handle specific deletion errors
try {
    await flowManager.deleteFlow(appId, flowId, token);
} catch (error) {
    if (error.message.includes('cannot be deleted')) {
        console.log('Flow is published - use deprecate API instead');
        // Redirect to deprecate flow
    } else if (error.message.includes('not found')) {
        console.log('Flow does not exist');
        // Handle non-existent flow
    } else if (error.message.includes('Unauthorized')) {
        console.log('Token expired or invalid');
        // Handle token refresh
    } else {
        console.log('Unexpected error:', error.message);
        // Handle other errors
    }
}
```

This comprehensive documentation covers all aspects of the Gupshup Partner API Delete Flow endpoint, including detailed Node.js examples, error handling, cleanup management, and best practices for production use.