# Gupshup Partner API - Deprecate Flow

## Overview
The Deprecate Flow API allows you to deprecate a flow that has been previously published. This endpoint is used to mark flows as deprecated, making them no longer available for new use while maintaining compatibility for existing implementations.

## Endpoint Details

**URL:** `https://partner.gupshup.io/partner/app/{appId}/flows/{flowId}/deprecate`  
**Method:** `POST`  
**Content-Type:** `application/json`

## Request Parameters

| Parameter | Description | Example | Type | Required | Notes |
|-----------|-------------|---------|------|----------|-------|
| Authorization | Access Token for the application | `{{PARTNER_APP_TOKEN}}` | String | Required | Should be a valid Partner App Access Token |
| appId | App ID to fetch the access token | `{{APP_ID}}` | String | Required | The Id should be a valid app Id of Gupshup |
| flowId | Flow Id | `{{FLOW_ID}}` | String | Required | Flow Id generated by Meta |

## Sample cURL Request

```bash
curl --location --globoff --request POST 'https://partner.gupshup.io/partner/app/{{APP_ID}}/flows/{{FLOW_ID}}/deprecate' \
--header 'Authorization: {{PARTNER_APP_TOKEN}}' \
--header 'Content-Type: application/json'
```

## Sample Response

### Success Response
```json
{
    "status": "success",
    "success": true
}
```

## Status Codes

| Code | Response | Description |
|------|----------|-------------|
| 200 | `{ "status": "success", "success": true }` | Successfully deprecate a flow |
| 400 | `{ "status": "error", "message": "Flow was never published, it cannot be deprecated" }` | For deprecating a draft flow |

## Node.js Code Examples

### Basic Flow Deprecation

```javascript
const axios = require('axios');

async function deprecateFlow(appId, flowId, token) {
    try {
        const response = await axios.post(
            `https://partner.gupshup.io/partner/app/${appId}/flows/${flowId}/deprecate`,
            {},
            {
                headers: {
                    'Authorization': token,
                    'Content-Type': 'application/json'
                }
            }
        );
        
        return response.data;
    } catch (error) {
        console.error('Error deprecating flow:', error.response?.data || error.message);
        throw error;
    }
}

// Usage
const appId = 'your-app-id';
const flowId = 'your-flow-id';
const token = 'your-partner-token';

deprecateFlow(appId, flowId, token)
    .then(result => {
        console.log('Flow deprecated successfully:', result);
    })
    .catch(error => {
        console.error('Failed to deprecate flow:', error);
    });
```

### With Enhanced Error Handling

```javascript
const axios = require('axios');

async function deprecateFlowWithErrorHandling(appId, flowId, token) {
    try {
        const response = await axios.post(
            `https://partner.gupshup.io/partner/app/${appId}/flows/${flowId}/deprecate`,
            {},
            {
                headers: {
                    'Authorization': token,
                    'Content-Type': 'application/json'
                },
                timeout: 10000 // 10 seconds timeout
            }
        );
        
        if (response.data.success) {
            return {
                success: true,
                message: 'Flow deprecated successfully',
                data: response.data
            };
        } else {
            return {
                success: false,
                message: 'Failed to deprecate flow',
                error: response.data
            };
        }
    } catch (error) {
        if (error.response) {
            // Server responded with error status
            const errorMessage = error.response.data?.message || 'Unknown server error';
            return {
                success: false,
                message: errorMessage,
                statusCode: error.response.status,
                error: error.response.data
            };
        } else if (error.request) {
            // Request was made but no response received
            return {
                success: false,
                message: 'No response received from server',
                error: 'Network error'
            };
        } else {
            // Something else happened
            return {
                success: false,
                message: 'Request setup error',
                error: error.message
            };
        }
    }
}

// Usage
deprecateFlowWithErrorHandling(appId, flowId, token)
    .then(result => {
        if (result.success) {
            console.log('✅ Flow deprecated successfully:', result.data);
        } else {
            console.error('❌ Failed to deprecate flow:', result.message);
        }
    });
```

### Complete Flow Deprecation Manager

```javascript
const axios = require('axios');

class FlowDeprecationManager {
    constructor(baseURL = 'https://partner.gupshup.io/partner', timeout = 10000) {
        this.baseURL = baseURL;
        this.timeout = timeout;
        this.axiosInstance = axios.create({
            baseURL: this.baseURL,
            timeout: this.timeout,
            headers: {
                'Content-Type': 'application/json'
            }
        });
    }

    async deprecateFlow(appId, flowId, token) {
        try {
            const response = await this.axiosInstance.post(
                `/app/${appId}/flows/${flowId}/deprecate`,
                {},
                {
                    headers: {
                        'Authorization': token
                    }
                }
            );
            
            return {
                success: true,
                data: response.data,
                timestamp: new Date().toISOString()
            };
        } catch (error) {
            throw this.handleError(error);
        }
    }

    async deprecateFlowWithValidation(appId, flowId, token) {
        // Validate input parameters
        if (!appId || !flowId || !token) {
            throw new Error('Missing required parameters: appId, flowId, and token are required');
        }

        try {
            const result = await this.deprecateFlow(appId, flowId, token);
            
            // Log successful deprecation
            this.logActivity('DEPRECATE_SUCCESS', {
                appId,
                flowId,
                timestamp: result.timestamp
            });
            
            return result;
        } catch (error) {
            // Log failed deprecation
            this.logActivity('DEPRECATE_FAILED', {
                appId,
                flowId,
                error: error.message,
                timestamp: new Date().toISOString()
            });
            
            throw error;
        }
    }

    async deprecateMultipleFlows(appId, flowIds, token) {
        const results = [];
        
        for (const flowId of flowIds) {
            try {
                const result = await this.deprecateFlow(appId, flowId, token);
                results.push({
                    flowId,
                    success: true,
                    result: result.data
                });
            } catch (error) {
                results.push({
                    flowId,
                    success: false,
                    error: error.message
                });
            }
        }
        
        return results;
    }

    async deprecateFlowWithRetry(appId, flowId, token, maxRetries = 3) {
        let lastError;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const result = await this.deprecateFlow(appId, flowId, token);
                
                if (attempt > 1) {
                    console.log(`✅ Flow deprecated successfully on attempt ${attempt}`);
                }
                
                return result;
            } catch (error) {
                lastError = error;
                
                if (attempt < maxRetries) {
                    const delay = Math.pow(2, attempt) * 1000; // Exponential backoff
                    console.log(`❌ Attempt ${attempt} failed, retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                } else {
                    console.log(`❌ All ${maxRetries} attempts failed`);
                }
            }
        }
        
        throw lastError;
    }

    async deprecateFlowWithConfirmation(appId, flowId, token, confirmationCallback) {
        try {
            // Get flow details before deprecation (if available)
            const flowDetails = await this.getFlowDetails(appId, flowId, token);
            
            // Ask for confirmation
            const confirmed = await confirmationCallback(flowDetails);
            
            if (!confirmed) {
                return {
                    success: false,
                    message: 'Deprecation cancelled by user',
                    cancelled: true
                };
            }
            
            // Proceed with deprecation
            const result = await this.deprecateFlow(appId, flowId, token);
            
            return {
                ...result,
                confirmed: true
            };
        } catch (error) {
            throw error;
        }
    }

    async getFlowDetails(appId, flowId, token) {
        try {
            // This would require implementing the get flow details API
            // For now, we'll return a placeholder
            return {
                flowId,
                appId,
                status: 'PUBLISHED',
                name: 'Flow Name'
            };
        } catch (error) {
            console.warn('Could not fetch flow details:', error.message);
            return { flowId, appId, status: 'UNKNOWN' };
        }
    }

    handleError(error) {
        if (error.response) {
            const { status, data } = error.response;
            
            switch (status) {
                case 400:
                    return new Error(data.message || 'Flow was never published, it cannot be deprecated');
                case 401:
                    return new Error('Unauthorized - Invalid or expired token');
                case 403:
                    return new Error('Forbidden - Insufficient permissions');
                case 404:
                    return new Error('Flow not found');
                case 429:
                    return new Error('Rate limit exceeded');
                case 500:
                    return new Error('Internal server error');
                default:
                    return new Error(`HTTP ${status}: ${data.message || 'Unknown error'}`);
            }
        } else if (error.request) {
            return new Error('Network error - No response received');
        } else {
            return new Error(`Request error: ${error.message}`);
        }
    }

    logActivity(action, details) {
        const logEntry = {
            action,
            timestamp: new Date().toISOString(),
            ...details
        };
        
        console.log(`[${action}]`, logEntry);
        
        // You can extend this to write to a file, database, or external logging service
    }

    // Utility method to check if flow can be deprecated
    async canFlowBeDeprecated(appId, flowId, token) {
        try {
            const flowDetails = await this.getFlowDetails(appId, flowId, token);
            return flowDetails.status === 'PUBLISHED';
        } catch (error) {
            console.warn('Could not verify flow status:', error.message);
            return false;
        }
    }
}

// Usage Examples
const flowManager = new FlowDeprecationManager();

// Basic usage
async function example1() {
    const appId = 'your-app-id';
    const flowId = 'your-flow-id';
    const token = 'your-partner-token';
    
    try {
        const result = await flowManager.deprecateFlow(appId, flowId, token);
        console.log('Flow deprecated:', result);
    } catch (error) {
        console.error('Error:', error.message);
    }
}

// With validation
async function example2() {
    const appId = 'your-app-id';
    const flowId = 'your-flow-id';
    const token = 'your-partner-token';
    
    try {
        const result = await flowManager.deprecateFlowWithValidation(appId, flowId, token);
        console.log('Flow deprecated with validation:', result);
    } catch (error) {
        console.error('Validation error:', error.message);
    }
}

// Deprecate multiple flows
async function example3() {
    const appId = 'your-app-id';
    const flowIds = ['flow1', 'flow2', 'flow3'];
    const token = 'your-partner-token';
    
    try {
        const results = await flowManager.deprecateMultipleFlows(appId, flowIds, token);
        console.log('Multiple flows deprecated:', results);
    } catch (error) {
        console.error('Error:', error.message);
    }
}

// With retry logic
async function example4() {
    const appId = 'your-app-id';
    const flowId = 'your-flow-id';
    const token = 'your-partner-token';
    
    try {
        const result = await flowManager.deprecateFlowWithRetry(appId, flowId, token, 3);
        console.log('Flow deprecated with retry:', result);
    } catch (error) {
        console.error('Final error after retries:', error.message);
    }
}

// With confirmation
async function example5() {
    const appId = 'your-app-id';
    const flowId = 'your-flow-id';
    const token = 'your-partner-token';
    
    const confirmationCallback = async (flowDetails) => {
        console.log('About to deprecate flow:', flowDetails);
        // In a real application, you might show a confirmation dialog
        return true; // or false to cancel
    };
    
    try {
        const result = await flowManager.deprecateFlowWithConfirmation(
            appId, 
            flowId, 
            token, 
            confirmationCallback
        );
        console.log('Flow deprecated with confirmation:', result);
    } catch (error) {
        console.error('Error:', error.message);
    }
}
```

### Integration with Flow Lifecycle Management

```javascript
// Advanced flow deprecation with lifecycle management
class FlowLifecycleManager {
    constructor(deprecationManager) {
        this.deprecationManager = deprecationManager;
        this.deprecationHistory = [];
    }

    async deprecateFlowWithLifecycle(appId, flowId, token, options = {}) {
        const {
            reason = 'Manual deprecation',
            replacementFlowId = null,
            notifyUsers = true,
            scheduleDate = null
        } = options;

        try {
            // Record deprecation intent
            const deprecationRecord = {
                appId,
                flowId,
                reason,
                replacementFlowId,
                scheduledDate: scheduleDate,
                initiatedAt: new Date().toISOString(),
                status: 'PENDING'
            };

            this.deprecationHistory.push(deprecationRecord);

            // If scheduled for future, add to schedule
            if (scheduleDate && new Date(scheduleDate) > new Date()) {
                return this.scheduleDeprecation(deprecationRecord);
            }

            // Notify users if required
            if (notifyUsers) {
                await this.notifyFlowUsers(appId, flowId, deprecationRecord);
            }

            // Perform deprecation
            const result = await this.deprecationManager.deprecateFlow(appId, flowId, token);

            // Update record
            deprecationRecord.status = 'COMPLETED';
            deprecationRecord.completedAt = new Date().toISOString();
            deprecationRecord.result = result;

            return {
                success: true,
                deprecationRecord,
                result
            };

        } catch (error) {
            // Update record with error
            const failedRecord = this.deprecationHistory.find(
                r => r.flowId === flowId && r.status === 'PENDING'
            );
            if (failedRecord) {
                failedRecord.status = 'FAILED';
                failedRecord.error = error.message;
                failedRecord.failedAt = new Date().toISOString();
            }

            throw error;
        }
    }

    async scheduleDeprecation(deprecationRecord) {
        console.log(`Scheduling deprecation for ${deprecationRecord.scheduledDate}`);
        
        // In a real implementation, you would store this in a database
        // and have a scheduler pick it up
        return {
            success: true,
            message: 'Deprecation scheduled successfully',
            scheduledFor: deprecationRecord.scheduledDate
        };
    }

    async notifyFlowUsers(appId, flowId, deprecationRecord) {
        // In a real implementation, you would send notifications
        console.log(`Notifying users about flow ${flowId} deprecation`);
        
        const notification = {
            type: 'FLOW_DEPRECATION',
            appId,
            flowId,
            message: `Flow ${flowId} will be deprecated. Reason: ${deprecationRecord.reason}`,
            replacementFlowId: deprecationRecord.replacementFlowId,
            timestamp: new Date().toISOString()
        };

        // Send notification through your preferred channel
        // (email, push notification, webhook, etc.)
        console.log('Notification sent:', notification);
    }

    getDeprecationHistory(flowId = null) {
        if (flowId) {
            return this.deprecationHistory.filter(record => record.flowId === flowId);
        }
        return this.deprecationHistory;
    }

    async bulkDeprecateFlows(appId, flowDeprecations, token) {
        const results = [];
        
        for (const deprecation of flowDeprecations) {
            try {
                const result = await this.deprecateFlowWithLifecycle(
                    appId,
                    deprecation.flowId,
                    token,
                    deprecation.options
                );
                results.push({
                    flowId: deprecation.flowId,
                    success: true,
                    result
                });
            } catch (error) {
                results.push({
                    flowId: deprecation.flowId,
                    success: false,
                    error: error.message
                });
            }
        }
        
        return results;
    }
}

// Usage
const deprecationManager = new FlowDeprecationManager();
const lifecycleManager = new FlowLifecycleManager(deprecationManager);

// Deprecate with lifecycle management
async function lifecycleExample() {
    const appId = 'your-app-id';
    const flowId = 'your-flow-id';
    const token = 'your-partner-token';
    
    try {
        const result = await lifecycleManager.deprecateFlowWithLifecycle(
            appId,
            flowId,
            token,
            {
                reason: 'Security update required',
                replacementFlowId: 'new-flow-id',
                notifyUsers: true,
                scheduleDate: null // Immediate deprecation
            }
        );
        
        console.log('Flow deprecated with lifecycle management:', result);
    } catch (error) {
        console.error('Lifecycle deprecation error:', error.message);
    }
}

// Bulk deprecation
async function bulkDeprecationExample() {
    const appId = 'your-app-id';
    const token = 'your-partner-token';
    
    const flowDeprecations = [
        {
            flowId: 'flow1',
            options: {
                reason: 'Version upgrade',
                replacementFlowId: 'flow1-v2'
            }
        },
        {
            flowId: 'flow2',
            options: {
                reason: 'Feature deprecation',
                notifyUsers: true
            }
        }
    ];
    
    try {
        const results = await lifecycleManager.bulkDeprecateFlows(
            appId,
            flowDeprecations,
            token
        );
        
        console.log('Bulk deprecation results:', results);
    } catch (error) {
        console.error('Bulk deprecation error:', error.message);
    }
}
```

## Best Practices

### 1. Flow State Validation
- Always verify that the flow is in PUBLISHED state before attempting to deprecate
- Handle the specific error when flow was never published

### 2. User Communication
- Notify users before deprecating flows that are actively in use
- Provide clear migration paths and replacement flows

### 3. Lifecycle Management
- Maintain records of all deprecation activities
- Implement proper scheduling for planned deprecations
- Track replacement flows and migration status

### 4. Error Handling
- Implement proper error handling for network issues and API errors
- Use retry logic with exponential backoff for transient failures

### 5. Monitoring and Logging
- Log all deprecation attempts and their outcomes
- Monitor deprecation patterns and success rates
- Track the impact of deprecations on users

## Common Use Cases

1. **Security Updates**: Deprecate flows with security vulnerabilities
2. **Feature Sunset**: Remove deprecated features systematically
3. **Version Management**: Deprecate old versions when new ones are available
4. **Compliance**: Deprecate flows that no longer meet regulatory requirements
5. **Performance**: Replace poorly performing flows with optimized versions

## Important Notes

- Only published flows can be deprecated
- Deprecation is typically irreversible through the API
- Consider the impact on existing users before deprecating flows
- Always provide migration paths for deprecated flows
- Monitor usage patterns before and after deprecation

## Error Handling Examples

```javascript
// Handle specific deprecation errors
try {
    await flowManager.deprecateFlow(appId, flowId, token);
} catch (error) {
    if (error.message.includes('never published')) {
        console.log('Flow is in draft state and cannot be deprecated');
        // Handle draft flow case
    } else if (error.message.includes('Unauthorized')) {
        console.log('Token expired or invalid');
        // Handle token refresh
    } else {
        console.log('Unexpected error:', error.message);
        // Handle other errors
    }
}
```

This comprehensive documentation covers all aspects of the Gupshup Partner API Deprecate Flow endpoint, including detailed Node.js examples, error handling, lifecycle management, and best practices for production use.