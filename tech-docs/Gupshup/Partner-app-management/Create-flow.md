# Flow Management API

The Flow Management API provides comprehensive functionality to manage WhatsApp Business flows throughout their entire lifecycle. This API allows you to create, update, publish, deprecate, and delete flows for your WhatsApp Business applications.

## API Overview

| Feature | Description |
|---------|-------------|
| **Base URL** | `https://partner.gupshup.io/partner/app/{appId}/flows` |
| **Authentication** | Bearer Token (Partner App Token) |
| **Content Type** | `application/json` |

## Important Note

> **ðŸ“˜ NOTE:** Only flows without an endpoint are currently supported. Flows with an endpoint are in alpha testing.

## Authentication

All requests require a valid Partner App Token in the Authorization header:

```bash
Authorization: YOUR_PARTNER_APP_TOKEN
```

## Flow Lifecycle

Flows have different states throughout their lifecycle:
- **DRAFT**: Flow is in draft state and can be modified
- **PUBLISHED**: Flow is published and active
- **DEPRECATED**: Flow is deprecated and no longer active

## Available Endpoints

### 1. Create Flow

Create a new flow for your WhatsApp Business application.

**Endpoint:** `POST /partner/app/{appId}/flows`

#### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `appId` | string | Yes | App ID of the application |
| `name` | string | Yes | Name of the flow (must be unique within WABA) |
| `categories` | array | Yes | List of flow categories |

#### Sample Request (cURL)

```bash
curl --location --request POST 'https://partner.gupshup.io/partner/app/YOUR_APP_ID/flows/' \
--header 'Authorization: YOUR_PARTNER_APP_TOKEN' \
--header 'Content-Type: application/json' \
--data-raw '{
  "name": "Customer Support Flow",
  "categories": ["SUPPORT"]
}'
```

#### Sample Response

```json
{
  "id": "1616289422261049",
  "status": "success"
}
```

#### Response Fields

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Flow ID generated by Meta |
| `status` | string | Response status (`success` or `error`) |

### 2. Update Flow

Update an existing flow that is in DRAFT state.

**Endpoint:** `PUT /partner/app/{appId}/flows/{flowId}`

#### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `appId` | string | Yes | App ID of the application |
| `flowId` | string | Yes | Flow ID generated by Meta |
| `name` | string | Yes | Updated name of the flow |
| `categories` | array | Yes | Updated list of flow categories |

#### Sample Request (cURL)

```bash
curl --location --globoff --request PUT 'https://partner.gupshup.io/partner/app/YOUR_APP_ID/flows/YOUR_FLOW_ID' \
--header 'Authorization: YOUR_PARTNER_APP_TOKEN' \
--header 'Content-Type: application/json' \
--data '{
  "name": "Updated Customer Support Flow",
  "categories": ["SUPPORT", "FAQ"]
}'
```

#### Sample Response

```json
{
  "status": "success",
  "success": true
}
```

### 3. Publish Flow

Publish a flow that is in DRAFT state to make it active.

**Endpoint:** `POST /partner/app/{appId}/flows/{flowId}/publish`

#### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `appId` | string | Yes | App ID of the application |
| `flowId` | string | Yes | Flow ID generated by Meta |

#### Sample Request (cURL)

```bash
curl --location --globoff --request POST 'https://partner.gupshup.io/partner/app/YOUR_APP_ID/flows/YOUR_FLOW_ID/publish' \
--header 'Authorization: YOUR_PARTNER_APP_TOKEN' \
--header 'Content-Type: application/json'
```

#### Sample Response

```json
{
  "status": "success",
  "success": true
}
```

### 4. Deprecate Flow

Deprecate a published flow to deactivate it.

**Endpoint:** `POST /partner/app/{appId}/flows/{flowId}/deprecate`

#### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `appId` | string | Yes | App ID of the application |
| `flowId` | string | Yes | Flow ID generated by Meta |

#### Sample Request (cURL)

```bash
curl --location --globoff --request POST 'https://partner.gupshup.io/partner/app/YOUR_APP_ID/flows/YOUR_FLOW_ID/deprecate' \
--header 'Authorization: YOUR_PARTNER_APP_TOKEN' \
--header 'Content-Type: application/json'
```

#### Sample Response

```json
{
  "status": "success",
  "success": true
}
```

### 5. Delete Flow

Delete a flow that is in DRAFT state.

**Endpoint:** `DELETE /partner/app/{appId}/flows/{flowId}`

#### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `appId` | string | Yes | App ID of the application |
| `flowId` | string | Yes | Flow ID generated by Meta |

#### Sample Request (cURL)

```bash
curl --location --request DELETE 'https://partner.gupshup.io/partner/app/YOUR_APP_ID/flows/YOUR_FLOW_ID' \
--header 'Authorization: YOUR_PARTNER_APP_TOKEN' \
--header 'Content-Type: application/json'
```

#### Sample Response

```json
{
  "status": "success",
  "success": true
}
```

## Status Codes

| Status | Response | Description |
|--------|----------|-------------|
| **Success** | | |
| 200 | `{"id": "...", "status": "success"}` | Flow created successfully |
| 200 | `{"status": "success", "success": true}` | Operation completed successfully |
| **Error** | | |
| 400 | `{"status": "error", "message": "Flow name should be unique..."}` | Flow name not unique |
| 400 | `{"status": "error", "message": "Flow can only be modified in Draft status"}` | Cannot modify non-draft flow |
| 400 | `{"status": "error", "message": "Flow cannot be published as it's not in DRAFT state"}` | Cannot publish non-draft flow |
| 400 | `{"status": "error", "message": "Flow was never published, it cannot be deprecated"}` | Cannot deprecate unpublished flow |
| 400 | `{"status": "error", "message": "After a flow has been published, it cannot be deleted..."}` | Cannot delete published flow |

## Node.js Examples

### Basic Usage

```javascript
const axios = require('axios');

class FlowManager {
  constructor(partnerAppToken) {
    this.partnerAppToken = partnerAppToken;
    this.baseURL = 'https://partner.gupshup.io/partner/app';
  }

  // Create a new flow
  async createFlow(appId, flowData) {
    try {
      const response = await axios.post(
        `${this.baseURL}/${appId}/flows/`,
        {
          name: flowData.name,
          categories: flowData.categories
        },
        {
          headers: {
            'Authorization': `Bearer ${this.partnerAppToken}`,
            'Content-Type': 'application/json'
          }
        }
      );

      return response.data;
    } catch (error) {
      console.error('Error creating flow:', error.response?.data || error.message);
      throw error;
    }
  }

  // Update an existing flow
  async updateFlow(appId, flowId, flowData) {
    try {
      const response = await axios.put(
        `${this.baseURL}/${appId}/flows/${flowId}`,
        {
          name: flowData.name,
          categories: flowData.categories
        },
        {
          headers: {
            'Authorization': `Bearer ${this.partnerAppToken}`,
            'Content-Type': 'application/json'
          }
        }
      );

      return response.data;
    } catch (error) {
      console.error('Error updating flow:', error.response?.data || error.message);
      throw error;
    }
  }

  // Publish a flow
  async publishFlow(appId, flowId) {
    try {
      const response = await axios.post(
        `${this.baseURL}/${appId}/flows/${flowId}/publish`,
        {},
        {
          headers: {
            'Authorization': `Bearer ${this.partnerAppToken}`,
            'Content-Type': 'application/json'
          }
        }
      );

      return response.data;
    } catch (error) {
      console.error('Error publishing flow:', error.response?.data || error.message);
      throw error;
    }
  }

  // Deprecate a flow
  async deprecateFlow(appId, flowId) {
    try {
      const response = await axios.post(
        `${this.baseURL}/${appId}/flows/${flowId}/deprecate`,
        {},
        {
          headers: {
            'Authorization': `Bearer ${this.partnerAppToken}`,
            'Content-Type': 'application/json'
          }
        }
      );

      return response.data;
    } catch (error) {
      console.error('Error deprecating flow:', error.response?.data || error.message);
      throw error;
    }
  }

  // Delete a flow
  async deleteFlow(appId, flowId) {
    try {
      const response = await axios.delete(
        `${this.baseURL}/${appId}/flows/${flowId}`,
        {
          headers: {
            'Authorization': `Bearer ${this.partnerAppToken}`,
            'Content-Type': 'application/json'
          }
        }
      );

      return response.data;
    } catch (error) {
      console.error('Error deleting flow:', error.response?.data || error.message);
      throw error;
    }
  }
}

// Usage example
const flowManager = new FlowManager('YOUR_PARTNER_APP_TOKEN');

// Create a new flow
async function createNewFlow() {
  try {
    const flowData = {
      name: 'Customer Support Flow',
      categories: ['SUPPORT']
    };

    const result = await flowManager.createFlow('YOUR_APP_ID', flowData);
    console.log('Flow created:', result);
    console.log('Flow ID:', result.id);
    return result;
  } catch (error) {
    console.error('Failed to create flow:', error);
  }
}

// Update a flow
async function updateExistingFlow() {
  try {
    const flowData = {
      name: 'Updated Customer Support Flow',
      categories: ['SUPPORT', 'FAQ']
    };

    const result = await flowManager.updateFlow('YOUR_APP_ID', 'YOUR_FLOW_ID', flowData);
    console.log('Flow updated:', result);
    return result;
  } catch (error) {
    console.error('Failed to update flow:', error);
  }
}

// Publish a flow
async function publishFlow() {
  try {
    const result = await flowManager.publishFlow('YOUR_APP_ID', 'YOUR_FLOW_ID');
    console.log('Flow published:', result);
    return result;
  } catch (error) {
    console.error('Failed to publish flow:', error);
  }
}
```

### Advanced Usage with Validation

```javascript
class AdvancedFlowManager extends FlowManager {
  // Validate flow data
  validateFlowData(flowData) {
    const errors = [];

    if (!flowData.name || typeof flowData.name !== 'string') {
      errors.push('Flow name is required and must be a string');
    }

    if (!flowData.categories || !Array.isArray(flowData.categories)) {
      errors.push('Categories are required and must be an array');
    } else if (flowData.categories.length === 0) {
      errors.push('At least one category is required');
    }

    return errors;
  }

  // Create flow with validation
  async createValidatedFlow(appId, flowData) {
    try {
      const errors = this.validateFlowData(flowData);
      if (errors.length > 0) {
        throw new Error(`Validation failed: ${errors.join(', ')}`);
      }

      const result = await this.createFlow(appId, flowData);
      console.log(`Flow "${flowData.name}" created successfully with ID: ${result.id}`);
      return result;
    } catch (error) {
      console.error('Flow creation failed:', error.message);
      throw error;
    }
  }

  // Update flow with validation
  async updateValidatedFlow(appId, flowId, flowData) {
    try {
      const errors = this.validateFlowData(flowData);
      if (errors.length > 0) {
        throw new Error(`Validation failed: ${errors.join(', ')}`);
      }

      const result = await this.updateFlow(appId, flowId, flowData);
      console.log(`Flow "${flowData.name}" updated successfully`);
      return result;
    } catch (error) {
      console.error('Flow update failed:', error.message);
      throw error;
    }
  }

  // Complete flow lifecycle management
  async manageFlowLifecycle(appId, flowData) {
    try {
      console.log('Starting flow lifecycle management...');
      
      // Step 1: Create flow
      console.log('Step 1: Creating flow...');
      const createResult = await this.createValidatedFlow(appId, flowData);
      const flowId = createResult.id;
      
      // Step 2: Update flow if needed
      console.log('Step 2: Flow created, ready for updates...');
      
      // Step 3: Publish flow
      console.log('Step 3: Publishing flow...');
      const publishResult = await this.publishFlow(appId, flowId);
      
      console.log('Flow lifecycle completed successfully');
      return {
        flowId,
        createResult,
        publishResult,
        status: 'PUBLISHED'
      };
      
    } catch (error) {
      console.error('Flow lifecycle management failed:', error);
      throw error;
    }
  }

  // Safely delete or deprecate flow
  async safelyRemoveFlow(appId, flowId) {
    try {
      console.log('Attempting to remove flow...');
      
      // Try to delete first (works only for draft flows)
      try {
        const deleteResult = await this.deleteFlow(appId, flowId);
        console.log('Flow deleted successfully');
        return { action: 'DELETED', result: deleteResult };
      } catch (deleteError) {
        console.log('Cannot delete flow, attempting to deprecate...');
        
        // If delete fails, try to deprecate
        const deprecateResult = await this.deprecateFlow(appId, flowId);
        console.log('Flow deprecated successfully');
        return { action: 'DEPRECATED', result: deprecateResult };
      }
      
    } catch (error) {
      console.error('Failed to remove flow:', error);
      throw error;
    }
  }

  // Batch operations
  async batchCreateFlows(appId, flowsData) {
    const results = [];
    const errors = [];

    for (const flowData of flowsData) {
      try {
        const result = await this.createValidatedFlow(appId, flowData);
        results.push({ flowData, result, status: 'SUCCESS' });
        
        // Add delay to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 1000));
      } catch (error) {
        errors.push({ flowData, error: error.message, status: 'FAILED' });
      }
    }

    return {
      successful: results,
      failed: errors,
      summary: {
        total: flowsData.length,
        successful: results.length,
        failed: errors.length
      }
    };
  }
}

// Usage examples
const advancedManager = new AdvancedFlowManager('YOUR_PARTNER_APP_TOKEN');

async function demonstrateAdvancedFeatures() {
  try {
    // Create and publish a flow
    const flowData = {
      name: 'Advanced Customer Support Flow',
      categories: ['SUPPORT', 'FAQ']
    };

    const lifecycleResult = await advancedManager.manageFlowLifecycle('YOUR_APP_ID', flowData);
    console.log('Flow lifecycle result:', lifecycleResult);

    // Safely remove flow
    const removeResult = await advancedManager.safelyRemoveFlow('YOUR_APP_ID', lifecycleResult.flowId);
    console.log('Flow removal result:', removeResult);

    // Batch create flows
    const batchFlows = [
      { name: 'Order Support Flow', categories: ['SUPPORT', 'ORDERS'] },
      { name: 'Payment Support Flow', categories: ['SUPPORT', 'PAYMENTS'] },
      { name: 'General FAQ Flow', categories: ['FAQ'] }
    ];

    const batchResult = await advancedManager.batchCreateFlows('YOUR_APP_ID', batchFlows);
    console.log('Batch creation result:', batchResult);

  } catch (error) {
    console.error('Advanced features demonstration failed:', error);
  }
}
```

### Flow State Management

```javascript
class FlowStateManager {
  constructor(flowManager) {
    this.flowManager = flowManager;
    this.flowStates = new Map();
  }

  // Track flow state
  trackFlow(flowId, state, metadata = {}) {
    this.flowStates.set(flowId, {
      state,
      metadata,
      lastUpdated: Date.now()
    });
  }

  // Get flow state
  getFlowState(flowId) {
    return this.flowStates.get(flowId);
  }

  // Create and track flow
  async createAndTrackFlow(appId, flowData) {
    try {
      const result = await this.flowManager.createValidatedFlow(appId, flowData);
      this.trackFlow(result.id, 'DRAFT', { name: flowData.name, categories: flowData.categories });
      return result;
    } catch (error) {
      console.error('Failed to create and track flow:', error);
      throw error;
    }
  }

  // Update and track flow
  async updateAndTrackFlow(appId, flowId, flowData) {
    try {
      const result = await this.flowManager.updateValidatedFlow(appId, flowId, flowData);
      this.trackFlow(flowId, 'DRAFT', { name: flowData.name, categories: flowData.categories });
      return result;
    } catch (error) {
      console.error('Failed to update and track flow:', error);
      throw error;
    }
  }

  // Publish and track flow
  async publishAndTrackFlow(appId, flowId) {
    try {
      const result = await this.flowManager.publishFlow(appId, flowId);
      this.trackFlow(flowId, 'PUBLISHED', { publishedAt: Date.now() });
      return result;
    } catch (error) {
      console.error('Failed to publish and track flow:', error);
      throw error;
    }
  }

  // Deprecate and track flow
  async deprecateAndTrackFlow(appId, flowId) {
    try {
      const result = await this.flowManager.deprecateFlow(appId, flowId);
      this.trackFlow(flowId, 'DEPRECATED', { deprecatedAt: Date.now() });
      return result;
    } catch (error) {
      console.error('Failed to deprecate and track flow:', error);
      throw error;
    }
  }

  // Delete and untrack flow
  async deleteAndUntrackFlow(appId, flowId) {
    try {
      const result = await this.flowManager.deleteFlow(appId, flowId);
      this.flowStates.delete(flowId);
      return result;
    } catch (error) {
      console.error('Failed to delete and untrack flow:', error);
      throw error;
    }
  }

  // Get flows by state
  getFlowsByState(state) {
    const flows = [];
    for (const [flowId, flowData] of this.flowStates) {
      if (flowData.state === state) {
        flows.push({ flowId, ...flowData });
      }
    }
    return flows;
  }

  // Get all tracked flows
  getAllTrackedFlows() {
    const flows = [];
    for (const [flowId, flowData] of this.flowStates) {
      flows.push({ flowId, ...flowData });
    }
    return flows;
  }

  // Export flow states
  exportFlowStates() {
    return Object.fromEntries(this.flowStates);
  }

  // Import flow states
  importFlowStates(states) {
    this.flowStates = new Map(Object.entries(states));
  }
}

// Usage example
async function demonstrateFlowStateManagement() {
  try {
    const flowManager = new AdvancedFlowManager('YOUR_PARTNER_APP_TOKEN');
    const stateManager = new FlowStateManager(flowManager);

    // Create and track multiple flows
    const flows = [
      { name: 'Customer Onboarding Flow', categories: ['ONBOARDING'] },
      { name: 'Product Catalog Flow', categories: ['CATALOG'] },
      { name: 'Order Tracking Flow', categories: ['ORDERS'] }
    ];

    const createdFlows = [];
    for (const flowData of flows) {
      const result = await stateManager.createAndTrackFlow('YOUR_APP_ID', flowData);
      createdFlows.push(result);
    }

    // Publish some flows
    for (const flow of createdFlows.slice(0, 2)) {
      await stateManager.publishAndTrackFlow('YOUR_APP_ID', flow.id);
    }

    // Get flows by state
    const draftFlows = stateManager.getFlowsByState('DRAFT');
    const publishedFlows = stateManager.getFlowsByState('PUBLISHED');

    console.log('Draft flows:', draftFlows);
    console.log('Published flows:', publishedFlows);

    // Export states
    const exportedStates = stateManager.exportFlowStates();
    console.log('Exported states:', exportedStates);

  } catch (error) {
    console.error('Flow state management demonstration failed:', error);
  }
}
```

### Flow Categories and Templates

```javascript
class FlowTemplateManager {
  // Predefined flow categories
  static CATEGORIES = {
    SUPPORT: 'SUPPORT',
    FAQ: 'FAQ',
    ORDERS: 'ORDERS',
    PAYMENTS: 'PAYMENTS',
    ONBOARDING: 'ONBOARDING',
    CATALOG: 'CATALOG',
    FEEDBACK: 'FEEDBACK',
    NOTIFICATIONS: 'NOTIFICATIONS'
  };

  // Flow templates
  static getTemplates() {
    return {
      customerSupport: {
        name: 'Customer Support Flow',
        categories: [this.CATEGORIES.SUPPORT, this.CATEGORIES.FAQ],
        description: 'General customer support and FAQ flow'
      },
      orderTracking: {
        name: 'Order Tracking Flow',
        categories: [this.CATEGORIES.ORDERS],
        description: 'Flow for tracking order status and updates'
      },
      paymentSupport: {
        name: 'Payment Support Flow',
        categories: [this.CATEGORIES.PAYMENTS, this.CATEGORIES.SUPPORT],
        description: 'Flow for payment-related queries and support'
      },
      productCatalog: {
        name: 'Product Catalog Flow',
        categories: [this.CATEGORIES.CATALOG],
        description: 'Flow for browsing product catalog'
      },
      customerOnboarding: {
        name: 'Customer Onboarding Flow',
        categories: [this.CATEGORIES.ONBOARDING],
        description: 'Flow for onboarding new customers'
      },
      feedbackCollection: {
        name: 'Feedback Collection Flow',
        categories: [this.CATEGORIES.FEEDBACK],
        description: 'Flow for collecting customer feedback'
      }
    };
  }

  // Create flow from template
  static createFromTemplate(templateName, customName = null) {
    const templates = this.getTemplates();
    const template = templates[templateName];
    
    if (!template) {
      throw new Error(`Template "${templateName}" not found`);
    }

    return {
      name: customName || template.name,
      categories: template.categories,
      description: template.description
    };
  }

  // List available templates
  static listTemplates() {
    const templates = this.getTemplates();
    return Object.keys(templates).map(key => ({
      key,
      name: templates[key].name,
      categories: templates[key].categories,
      description: templates[key].description
    }));
  }

  // Validate categories
  static validateCategories(categories) {
    const validCategories = Object.values(this.CATEGORIES);
    const invalidCategories = categories.filter(cat => !validCategories.includes(cat));
    
    if (invalidCategories.length > 0) {
      throw new Error(`Invalid categories: ${invalidCategories.join(', ')}`);
    }
    
    return true;
  }
}

// Usage example
async function demonstrateFlowTemplates() {
  try {
    const flowManager = new AdvancedFlowManager('YOUR_PARTNER_APP_TOKEN');

    // List available templates
    const templates = FlowTemplateManager.listTemplates();
    console.log('Available templates:', templates);

    // Create flows from templates
    const supportFlow = FlowTemplateManager.createFromTemplate('customerSupport');
    const orderFlow = FlowTemplateManager.createFromTemplate('orderTracking', 'My Order Tracking Flow');

    console.log('Support flow template:', supportFlow);
    console.log('Order flow template:', orderFlow);

    // Create actual flows from templates
    const supportResult = await flowManager.createValidatedFlow('YOUR_APP_ID', supportFlow);
    const orderResult = await flowManager.createValidatedFlow('YOUR_APP_ID', orderFlow);

    console.log('Support flow created:', supportResult);
    console.log('Order flow created:', orderResult);

  } catch (error) {
    console.error('Flow template demonstration failed:', error);
  }
}
```

## Best Practices

1. **Unique Names**: Ensure flow names are unique within your WhatsApp Business Account
2. **State Management**: Track flow states to manage the lifecycle properly
3. **Error Handling**: Implement comprehensive error handling for different scenarios
4. **Categories**: Use appropriate categories to organize your flows
5. **Validation**: Validate flow data before creation or updates
6. **Lifecycle Management**: Follow proper flow lifecycle (Draft â†’ Published â†’ Deprecated)
7. **Batch Operations**: Use batch operations for managing multiple flows
8. **Templates**: Use templates for consistent flow creation
9. **Monitoring**: Monitor flow performance and usage
10. **Documentation**: Document your flows and their purposes

## Flow States and Transitions

| Current State | Available Actions | Next State |
|---------------|------------------|------------|
| DRAFT | Update, Publish, Delete | DRAFT, PUBLISHED, DELETED |
| PUBLISHED | Deprecate | DEPRECATED |
| DEPRECATED | - | - |

## Important Notes

- **Only Draft Flows**: Can be updated or deleted
- **Published Flows**: Cannot be modified, only deprecated
- **Deprecated Flows**: Cannot be restored or modified
- **Unique Names**: Flow names must be unique within the WABA
- **Categories**: Use appropriate categories for better organization
- **Alpha Features**: Flows with endpoints are in alpha testing
- **Meta Integration**: Flow IDs are generated by Meta platform