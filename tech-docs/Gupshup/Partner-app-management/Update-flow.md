# Update Flow API

The Update Flow API allows you to modify existing WhatsApp Business flows that are in DRAFT status. This API enables you to update flow properties such as name and categories while maintaining the flow's structure and configuration.

## API Overview

| Feature | Description |
|---------|-------------|
| **Base URL** | `https://partner.gupshup.io/partner/app/{appId}/flows/{flowId}` |
| **Authentication** | Bearer Token (Partner App Token) |
| **HTTP Method** | PUT |
| **Content Type** | `application/json` |

## Important Note

> **⚠️ Restriction:** Flows can only be modified when they are in **DRAFT** status. Published or deprecated flows cannot be updated.

## Authentication

All requests require a valid Partner App Token in the Authorization header:

```bash
Authorization: Bearer YOUR_PARTNER_APP_TOKEN
```

## Endpoint

### Update Flow

Update an existing flow's properties.

**Endpoint:** `PUT /partner/app/{appId}/flows/{flowId}`

#### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `appId` | string | Yes | App ID of the application |
| `flowId` | string | Yes | Flow ID generated by Meta |
| `name` | string | Yes | Updated name of the flow |
| `categories` | array | Yes | Updated list of flow categories |

#### Request Body

```json
{
  "name": "Updated Flow Name",
  "categories": ["CATEGORY1", "CATEGORY2"]
}
```

#### Sample Request (cURL)

```bash
curl --location --globoff --request PUT 'https://partner.gupshup.io/partner/app/{{APP_ID}}/flows/{{FLOW_ID}}' \
--header 'Authorization: {{PARTNER_APP_TOKEN}}' \
--header 'Content-Type: application/json' \
--data '{
  "name": "{{FLOW_ID}}",
  "categories": ["{{CATEGORIES}}"]
}'
```

**Real Example:**
```bash
curl --location --globoff --request PUT 'https://partner.gupshup.io/partner/app/YOUR_APP_ID/flows/YOUR_FLOW_ID' \
--header 'Authorization: YOUR_PARTNER_APP_TOKEN' \
--header 'Content-Type: application/json' \
--data '{
  "name": "Updated Customer Support Flow",
  "categories": ["SUPPORT", "FAQ"]
}'
```

#### Sample Response

```json
{
  "status": "success",
  "success": true
}
```

#### Response Fields

| Field | Type | Description |
|-------|------|-------------|
| `status` | string | Response status (`success` or `error`) |
| `success` | boolean | Indicates if the operation was successful |

## Status Codes

| Status | Response | Description |
|--------|----------|-------------|
| **Success** | | |
| 200 | `{"status": "success", "success": true}` | Flow updated successfully |
| **Error** | | |
| 400 | `{"status": "error", "message": "Flow can only be modified in Draft status"}` | Flow not in draft state |
| 401 | `{"status": "error", "message": "Authentication Failed"}` | Invalid or missing token |
| 404 | `{"status": "error", "message": "Flow not found"}` | Invalid flow ID |

## Node.js Examples

### Basic Usage

```javascript
const axios = require('axios');

class FlowUpdateManager {
  constructor(partnerAppToken) {
    this.partnerAppToken = partnerAppToken;
    this.baseURL = 'https://partner.gupshup.io/partner/app';
  }

  // Update flow
  async updateFlow(appId, flowId, updateData) {
    try {
      const response = await axios.put(
        `${this.baseURL}/${appId}/flows/${flowId}`,
        {
          name: updateData.name,
          categories: updateData.categories
        },
        {
          headers: {
            'Authorization': `Bearer ${this.partnerAppToken}`,
            'Content-Type': 'application/json'
          }
        }
      );

      return response.data;
    } catch (error) {
      console.error('Error updating flow:', error.response?.data || error.message);
      throw error;
    }
  }

  // Update flow name only
  async updateFlowName(appId, flowId, newName) {
    try {
      // First, get current flow data to preserve categories
      const currentFlow = await this.getCurrentFlowData(appId, flowId);
      
      return await this.updateFlow(appId, flowId, {
        name: newName,
        categories: currentFlow.categories
      });
    } catch (error) {
      console.error('Error updating flow name:', error);
      throw error;
    }
  }

  // Update flow categories only
  async updateFlowCategories(appId, flowId, newCategories) {
    try {
      // First, get current flow data to preserve name
      const currentFlow = await this.getCurrentFlowData(appId, flowId);
      
      return await this.updateFlow(appId, flowId, {
        name: currentFlow.name,
        categories: newCategories
      });
    } catch (error) {
      console.error('Error updating flow categories:', error);
      throw error;
    }
  }

  // Helper method to get current flow data (assuming you have a get flow API)
  async getCurrentFlowData(appId, flowId) {
    try {
      const response = await axios.get(
        `${this.baseURL}/${appId}/flows/${flowId}`,
        {
          headers: {
            'Authorization': `Bearer ${this.partnerAppToken}`,
            'Content-Type': 'application/json'
          }
        }
      );

      return {
        name: response.data.name,
        categories: response.data.categories
      };
    } catch (error) {
      console.error('Error getting current flow data:', error);
      throw error;
    }
  }
}

// Usage example
const flowUpdateManager = new FlowUpdateManager('YOUR_PARTNER_APP_TOKEN');

// Update complete flow data
async function updateCompleteFlow() {
  try {
    const updateData = {
      name: 'Enhanced Customer Support Flow',
      categories: ['SUPPORT', 'FAQ', 'HELP']
    };

    const result = await flowUpdateManager.updateFlow('YOUR_APP_ID', 'YOUR_FLOW_ID', updateData);
    console.log('Flow updated successfully:', result);
    return result;
  } catch (error) {
    console.error('Failed to update flow:', error);
  }
}

// Update only flow name
async function updateFlowName() {
  try {
    const result = await flowUpdateManager.updateFlowName(
      'YOUR_APP_ID', 
      'YOUR_FLOW_ID', 
      'New Flow Name'
    );
    console.log('Flow name updated:', result);
    return result;
  } catch (error) {
    console.error('Failed to update flow name:', error);
  }
}

// Update only categories
async function updateFlowCategories() {
  try {
    const newCategories = ['SUPPORT', 'ORDERS', 'BILLING'];
    const result = await flowUpdateManager.updateFlowCategories(
      'YOUR_APP_ID', 
      'YOUR_FLOW_ID', 
      newCategories
    );
    console.log('Flow categories updated:', result);
    return result;
  } catch (error) {
    console.error('Failed to update flow categories:', error);
  }
}
```

### Advanced Usage with Validation

```javascript
class AdvancedFlowUpdateManager extends FlowUpdateManager {
  // Available flow categories
  static CATEGORIES = {
    SUPPORT: 'SUPPORT',
    FAQ: 'FAQ',
    ORDERS: 'ORDERS',
    PAYMENTS: 'PAYMENTS',
    ONBOARDING: 'ONBOARDING',
    CATALOG: 'CATALOG',
    FEEDBACK: 'FEEDBACK',
    NOTIFICATIONS: 'NOTIFICATIONS',
    HELP: 'HELP',
    BILLING: 'BILLING'
  };

  // Validate update data
  validateUpdateData(updateData) {
    const errors = [];

    // Validate name
    if (!updateData.name || typeof updateData.name !== 'string') {
      errors.push('Flow name is required and must be a string');
    } else if (updateData.name.trim().length === 0) {
      errors.push('Flow name cannot be empty');
    } else if (updateData.name.length > 100) {
      errors.push('Flow name must be 100 characters or less');
    }

    // Validate categories
    if (!updateData.categories || !Array.isArray(updateData.categories)) {
      errors.push('Categories are required and must be an array');
    } else if (updateData.categories.length === 0) {
      errors.push('At least one category is required');
    } else {
      const validCategories = Object.values(AdvancedFlowUpdateManager.CATEGORIES);
      const invalidCategories = updateData.categories.filter(cat => !validCategories.includes(cat));
      
      if (invalidCategories.length > 0) {
        errors.push(`Invalid categories: ${invalidCategories.join(', ')}`);
      }
    }

    return errors;
  }

  // Check if flow is in draft status
  async checkFlowStatus(appId, flowId) {
    try {
      const flowData = await this.getCurrentFlowData(appId, flowId);
      // Assuming the flow data includes status information
      return flowData.status === 'DRAFT';
    } catch (error) {
      console.error('Error checking flow status:', error);
      return false;
    }
  }

  // Update flow with validation
  async updateFlowWithValidation(appId, flowId, updateData) {
    try {
      // Validate update data
      const validationErrors = this.validateUpdateData(updateData);
      if (validationErrors.length > 0) {
        throw new Error(`Validation failed: ${validationErrors.join(', ')}`);
      }

      // Check if flow is in draft status
      const isDraft = await this.checkFlowStatus(appId, flowId);
      if (!isDraft) {
        throw new Error('Flow can only be modified in Draft status');
      }

      // Perform update
      const result = await this.updateFlow(appId, flowId, updateData);
      console.log(`Flow "${updateData.name}" updated successfully`);
      return result;
    } catch (error) {
      console.error('Flow update with validation failed:', error.message);
      throw error;
    }
  }

  // Batch update flows
  async batchUpdateFlows(appId, flowUpdates) {
    const results = [];
    const errors = [];

    for (const update of flowUpdates) {
      try {
        const result = await this.updateFlowWithValidation(appId, update.flowId, {
          name: update.name,
          categories: update.categories
        });
        
        results.push({
          flowId: update.flowId,
          result,
          status: 'SUCCESS'
        });

        // Add delay to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 1000));
      } catch (error) {
        errors.push({
          flowId: update.flowId,
          error: error.message,
          status: 'FAILED'
        });
      }
    }

    return {
      successful: results,
      failed: errors,
      summary: {
        total: flowUpdates.length,
        successful: results.length,
        failed: errors.length
      }
    };
  }

  // Update flow with retry logic
  async updateFlowWithRetry(appId, flowId, updateData, maxRetries = 3) {
    let lastError;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`Attempting to update flow (attempt ${attempt}/${maxRetries})`);
        const result = await this.updateFlowWithValidation(appId, flowId, updateData);
        console.log('Flow updated successfully on attempt', attempt);
        return result;
      } catch (error) {
        lastError = error;
        console.error(`Attempt ${attempt} failed:`, error.message);
        
        if (attempt < maxRetries) {
          const delay = Math.pow(2, attempt) * 1000; // Exponential backoff
          console.log(`Retrying in ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
    
    throw new Error(`Failed to update flow after ${maxRetries} attempts. Last error: ${lastError.message}`);
  }

  // Smart update (only update if changes detected)
  async smartUpdate(appId, flowId, newData) {
    try {
      const currentData = await this.getCurrentFlowData(appId, flowId);
      
      // Check if update is needed
      const nameChanged = currentData.name !== newData.name;
      const categoriesChanged = JSON.stringify(currentData.categories.sort()) !== 
                               JSON.stringify(newData.categories.sort());
      
      if (!nameChanged && !categoriesChanged) {
        console.log('No changes detected, skipping update');
        return { status: 'success', message: 'No changes detected' };
      }

      console.log('Changes detected:', { nameChanged, categoriesChanged });
      return await this.updateFlowWithValidation(appId, flowId, newData);
    } catch (error) {
      console.error('Smart update failed:', error);
      throw error;
    }
  }

  // Add category to existing flow
  async addCategory(appId, flowId, newCategory) {
    try {
      const currentData = await this.getCurrentFlowData(appId, flowId);
      
      if (currentData.categories.includes(newCategory)) {
        console.log('Category already exists');
        return { status: 'success', message: 'Category already exists' };
      }

      const updatedCategories = [...currentData.categories, newCategory];
      return await this.updateFlowWithValidation(appId, flowId, {
        name: currentData.name,
        categories: updatedCategories
      });
    } catch (error) {
      console.error('Failed to add category:', error);
      throw error;
    }
  }

  // Remove category from existing flow
  async removeCategory(appId, flowId, categoryToRemove) {
    try {
      const currentData = await this.getCurrentFlowData(appId, flowId);
      
      const updatedCategories = currentData.categories.filter(cat => cat !== categoryToRemove);
      
      if (updatedCategories.length === 0) {
        throw new Error('Cannot remove all categories. At least one category is required.');
      }

      return await this.updateFlowWithValidation(appId, flowId, {
        name: currentData.name,
        categories: updatedCategories
      });
    } catch (error) {
      console.error('Failed to remove category:', error);
      throw error;
    }
  }
}

// Usage examples
const advancedManager = new AdvancedFlowUpdateManager('YOUR_PARTNER_APP_TOKEN');

async function demonstrateAdvancedFeatures() {
  try {
    // Update with validation
    const updateData = {
      name: 'Advanced Customer Support Flow',
      categories: ['SUPPORT', 'FAQ']
    };

    await advancedManager.updateFlowWithValidation('YOUR_APP_ID', 'YOUR_FLOW_ID', updateData);
    console.log('Flow updated with validation');

    // Smart update (only if changes detected)
    await advancedManager.smartUpdate('YOUR_APP_ID', 'YOUR_FLOW_ID', {
      name: 'Advanced Customer Support Flow', // Same name
      categories: ['SUPPORT', 'FAQ', 'HELP'] // Added category
    });

    // Add category
    await advancedManager.addCategory('YOUR_APP_ID', 'YOUR_FLOW_ID', 'BILLING');
    console.log('Category added');

    // Remove category
    await advancedManager.removeCategory('YOUR_APP_ID', 'YOUR_FLOW_ID', 'HELP');
    console.log('Category removed');

    // Batch update
    const batchUpdates = [
      { flowId: 'FLOW_ID_1', name: 'Updated Flow 1', categories: ['SUPPORT'] },
      { flowId: 'FLOW_ID_2', name: 'Updated Flow 2', categories: ['FAQ'] }
    ];

    const batchResult = await advancedManager.batchUpdateFlows('YOUR_APP_ID', batchUpdates);
    console.log('Batch update result:', batchResult);

  } catch (error) {
    console.error('Advanced features demonstration failed:', error);
  }
}
```

### Flow Update History and Tracking

```javascript
class FlowUpdateTracker {
  constructor(flowUpdateManager) {
    this.flowUpdateManager = flowUpdateManager;
    this.updateHistory = new Map();
  }

  // Track flow update
  trackUpdate(appId, flowId, updateData, result) {
    const historyKey = `${appId}-${flowId}`;
    
    if (!this.updateHistory.has(historyKey)) {
      this.updateHistory.set(historyKey, []);
    }

    const updateEntry = {
      timestamp: Date.now(),
      updateData,
      result,
      success: result.status === 'success'
    };

    this.updateHistory.get(historyKey).push(updateEntry);
    
    // Keep only last 50 updates
    if (this.updateHistory.get(historyKey).length > 50) {
      this.updateHistory.set(historyKey, this.updateHistory.get(historyKey).slice(-50));
    }
  }

  // Update flow with tracking
  async updateFlowWithTracking(appId, flowId, updateData) {
    try {
      const result = await this.flowUpdateManager.updateFlowWithValidation(appId, flowId, updateData);
      this.trackUpdate(appId, flowId, updateData, result);
      return result;
    } catch (error) {
      this.trackUpdate(appId, flowId, updateData, { status: 'error', message: error.message });
      throw error;
    }
  }

  // Get update history
  getUpdateHistory(appId, flowId) {
    const historyKey = `${appId}-${flowId}`;
    return this.updateHistory.get(historyKey) || [];
  }

  // Get update statistics
  getUpdateStatistics(appId, flowId) {
    const history = this.getUpdateHistory(appId, flowId);
    
    if (history.length === 0) {
      return { totalUpdates: 0, successRate: 0, lastUpdate: null };
    }

    const successful = history.filter(update => update.success).length;
    const successRate = (successful / history.length * 100).toFixed(2);
    const lastUpdate = history[history.length - 1];

    return {
      totalUpdates: history.length,
      successful,
      failed: history.length - successful,
      successRate: `${successRate}%`,
      lastUpdate: {
        timestamp: new Date(lastUpdate.timestamp).toISOString(),
        success: lastUpdate.success,
        data: lastUpdate.updateData
      }
    };
  }

  // Export update history
  exportUpdateHistory(appId, flowId, filePath) {
    const history = this.getUpdateHistory(appId, flowId);
    const exportData = {
      appId,
      flowId,
      exportTimestamp: Date.now(),
      updateHistory: history.map(update => ({
        ...update,
        timestamp: new Date(update.timestamp).toISOString()
      }))
    };

    require('fs').writeFileSync(filePath, JSON.stringify(exportData, null, 2));
    console.log(`Update history exported to: ${filePath}`);
    return exportData;
  }

  // Clear update history
  clearUpdateHistory(appId, flowId) {
    const historyKey = `${appId}-${flowId}`;
    this.updateHistory.delete(historyKey);
    console.log('Update history cleared');
  }
}

// Usage example
async function demonstrateUpdateTracking() {
  try {
    const flowUpdateManager = new AdvancedFlowUpdateManager('YOUR_PARTNER_APP_TOKEN');
    const tracker = new FlowUpdateTracker(flowUpdateManager);

    // Update flow with tracking
    await tracker.updateFlowWithTracking('YOUR_APP_ID', 'YOUR_FLOW_ID', {
      name: 'Tracked Flow Update',
      categories: ['SUPPORT', 'FAQ']
    });

    // Get update statistics
    const stats = tracker.getUpdateStatistics('YOUR_APP_ID', 'YOUR_FLOW_ID');
    console.log('Update statistics:', stats);

    // Get update history
    const history = tracker.getUpdateHistory('YOUR_APP_ID', 'YOUR_FLOW_ID');
    console.log('Update history:', history);

    // Export history
    const exportPath = './flow-update-history.json';
    tracker.exportUpdateHistory('YOUR_APP_ID', 'YOUR_FLOW_ID', exportPath);

  } catch (error) {
    console.error('Update tracking demonstration failed:', error);
  }
}
```

### Flow Update Templates and Presets

```javascript
class FlowUpdateTemplates {
  // Predefined update templates
  static getTemplates() {
    return {
      customerSupport: {
        name: 'Customer Support Flow',
        categories: ['SUPPORT', 'FAQ', 'HELP'],
        description: 'Template for customer support and help flows'
      },
      ecommerce: {
        name: 'E-commerce Flow',
        categories: ['ORDERS', 'CATALOG', 'PAYMENTS'],
        description: 'Template for e-commerce related flows'
      },
      onboarding: {
        name: 'Customer Onboarding Flow',
        categories: ['ONBOARDING', 'HELP'],
        description: 'Template for customer onboarding flows'
      },
      feedback: {
        name: 'Feedback Collection Flow',
        categories: ['FEEDBACK', 'SUPPORT'],
        description: 'Template for feedback collection flows'
      },
      notifications: {
        name: 'Notification Flow',
        categories: ['NOTIFICATIONS'],
        description: 'Template for notification flows'
      }
    };
  }

  // Apply template to flow
  static applyTemplate(templateName, customName = null) {
    const templates = this.getTemplates();
    const template = templates[templateName];
    
    if (!template) {
      throw new Error(`Template "${templateName}" not found`);
    }

    return {
      name: customName || template.name,
      categories: [...template.categories], // Clone array
      templateUsed: templateName,
      description: template.description
    };
  }

  // List available templates
  static listTemplates() {
    const templates = this.getTemplates();
    return Object.keys(templates).map(key => ({
      key,
      name: templates[key].name,
      categories: templates[key].categories,
      description: templates[key].description
    }));
  }

  // Create custom template
  static createCustomTemplate(name, categories, description) {
    return {
      name,
      categories,
      description,
      isCustom: true
    };
  }
}

class FlowUpdatePresets {
  constructor(flowUpdateManager) {
    this.flowUpdateManager = flowUpdateManager;
    this.presets = new Map();
  }

  // Save update preset
  savePreset(presetName, updateData, description = '') {
    this.presets.set(presetName, {
      updateData,
      description,
      createdAt: Date.now()
    });
    console.log(`Preset "${presetName}" saved`);
  }

  // Load update preset
  loadPreset(presetName) {
    const preset = this.presets.get(presetName);
    if (!preset) {
      throw new Error(`Preset "${presetName}" not found`);
    }
    return preset.updateData;
  }

  // Apply preset to flow
  async applyPreset(appId, flowId, presetName) {
    try {
      const updateData = this.loadPreset(presetName);
      return await this.flowUpdateManager.updateFlowWithValidation(appId, flowId, updateData);
    } catch (error) {
      console.error('Failed to apply preset:', error);
      throw error;
    }
  }

  // List presets
  listPresets() {
    const presets = [];
    for (const [name, preset] of this.presets) {
      presets.push({
        name,
        description: preset.description,
        createdAt: new Date(preset.createdAt).toISOString(),
        updateData: preset.updateData
      });
    }
    return presets;
  }

  // Delete preset
  deletePreset(presetName) {
    const deleted = this.presets.delete(presetName);
    if (deleted) {
      console.log(`Preset "${presetName}" deleted`);
    } else {
      console.log(`Preset "${presetName}" not found`);
    }
    return deleted;
  }

  // Export presets
  exportPresets(filePath) {
    const exportData = {
      exportTimestamp: Date.now(),
      presets: Object.fromEntries(this.presets)
    };

    require('fs').writeFileSync(filePath, JSON.stringify(exportData, null, 2));
    console.log(`Presets exported to: ${filePath}`);
    return exportData;
  }

  // Import presets
  importPresets(filePath) {
    const importData = JSON.parse(require('fs').readFileSync(filePath, 'utf8'));
    this.presets = new Map(Object.entries(importData.presets));
    console.log(`Presets imported from: ${filePath}`);
    return this.presets.size;
  }
}

// Usage example
async function demonstrateTemplatesAndPresets() {
  try {
    const flowUpdateManager = new AdvancedFlowUpdateManager('YOUR_PARTNER_APP_TOKEN');
    const presets = new FlowUpdatePresets(flowUpdateManager);

    // List available templates
    const templates = FlowUpdateTemplates.listTemplates();
    console.log('Available templates:', templates);

    // Apply template
    const customerSupportTemplate = FlowUpdateTemplates.applyTemplate('customerSupport', 'My Support Flow');
    console.log('Customer support template:', customerSupportTemplate);

    // Save as preset
    presets.savePreset('supportFlowPreset', customerSupportTemplate, 'Standard customer support flow configuration');

    // Create custom template
    const customTemplate = FlowUpdateTemplates.createCustomTemplate(
      'Custom Business Flow',
      ['ORDERS', 'BILLING', 'SUPPORT'],
      'Custom template for business flows'
    );

    // Save custom template as preset
    presets.savePreset('customBusinessPreset', customTemplate, 'Custom business flow configuration');

    // Apply preset to flow
    await presets.applyPreset('YOUR_APP_ID', 'YOUR_FLOW_ID', 'supportFlowPreset');
    console.log('Preset applied to flow');

    // List all presets
    const allPresets = presets.listPresets();
    console.log('All presets:', allPresets);

    // Export presets
    const exportPath = './flow-presets.json';
    presets.exportPresets(exportPath);

  } catch (error) {
    console.error('Templates and presets demonstration failed:', error);
  }
}
```

## Best Practices

1. **Status Check**: Always verify flow is in DRAFT status before updating
2. **Validation**: Validate update data before sending requests
3. **Error Handling**: Handle specific error cases (draft status, validation errors)
4. **Atomic Updates**: Update all required fields in a single request
5. **Change Detection**: Only update when changes are detected
6. **Batch Operations**: Use batch operations for multiple flows with proper delays
7. **Templates**: Use templates for consistent flow configurations
8. **History Tracking**: Track update history for audit purposes
9. **Retry Logic**: Implement retry logic for transient failures
10. **Presets**: Save common configurations as reusable presets

## Flow Categories

Available categories for flows:

- `SUPPORT` - Customer support flows
- `FAQ` - Frequently asked questions
- `ORDERS` - Order management flows
- `PAYMENTS` - Payment processing flows
- `ONBOARDING` - Customer onboarding flows
- `CATALOG` - Product catalog flows
- `FEEDBACK` - Feedback collection flows
- `NOTIFICATIONS` - Notification flows
- `HELP` - Help and assistance flows
- `BILLING` - Billing and invoicing flows

## Common Use Cases

1. **Flow Optimization**: Update flow names and categories for better organization
2. **Category Management**: Add or remove categories as business needs change
3. **Batch Updates**: Update multiple flows with consistent configurations
4. **Template Application**: Apply standardized templates to flows
5. **Flow Maintenance**: Regular updates for flow optimization
6. **Rebranding**: Update flow names for rebranding initiatives
7. **Category Cleanup**: Organize flows with appropriate categories
8. **Configuration Management**: Manage flow configurations with presets

## Important Notes

- **Draft Status Required**: Flows can only be updated when they are in **DRAFT** status
- **Valid Flow ID**: The flow ID must be a valid Meta-generated Flow ID
- **Category Validation**: Categories must be valid flow categories supported by Meta
- **Immediate Updates**: Updates are applied immediately and cannot be undone
- **Data Persistence**: Always validate flow data before sending update requests
- **API Rate Limits**: Be mindful of API rate limits when performing batch updates
- **Token Security**: Keep your Partner App Token secure and never expose it in client-side code
- **Error Handling**: Implement comprehensive error handling for production use
- **Monitoring**: Use monitoring and health checks for production deployments
- **Audit Trail**: Maintain audit logs for compliance and debugging purposes

## Error Handling and Monitoring

### Comprehensive Error Handler

```javascript
class FlowUpdateErrorHandler {
  static handleError(error, context = {}) {
    const { appId, flowId, updateData } = context;
    
    if (error.response) {
      const { status, data } = error.response;
      
      switch (status) {
        case 400:
          if (data.message === 'Flow can only be modified in Draft status') {
            console.error(`Flow ${flowId} is not in Draft status`);
            return {
              code: 'FLOW_NOT_DRAFT',
              message: 'Flow can only be modified in Draft status',
              retryable: false,
              action: 'Check flow status and ensure it is in Draft state'
            };
          }
          return {
            code: 'BAD_REQUEST',
            message: data.message || 'Invalid request parameters',
            retryable: false,
            action: 'Validate request parameters and try again'
          };
          
        case 401:
          return {
            code: 'UNAUTHORIZED',
            message: 'Authentication failed - Invalid or expired token',
            retryable: false,
            action: 'Refresh partner app token and try again'
          };
          
        case 403:
          return {
            code: 'FORBIDDEN',
            message: 'Access denied - Insufficient permissions',
            retryable: false,
            action: 'Check app permissions and token scope'
          };
          
        case 404:
          return {
            code: 'NOT_FOUND',
            message: `Flow ${flowId} not found for app ${appId}`,
            retryable: false,
            action: 'Verify flow ID and app ID are correct'
          };
          
        case 429:
          return {
            code: 'RATE_LIMITED',
            message: 'Too many requests - Rate limit exceeded',
            retryable: true,
            action: 'Implement exponential backoff and retry later'
          };
          
        case 500:
        case 502:
        case 503:
        case 504:
          return {
            code: 'SERVER_ERROR',
            message: 'Server error - Service temporarily unavailable',
            retryable: true,
            action: 'Retry with exponential backoff'
          };
          
        default:
          return {
            code: 'UNKNOWN_HTTP_ERROR',
            message: `HTTP ${status}: ${data.message || 'Unknown error'}`,
            retryable: status >= 500,
            action: 'Check API documentation and try again'
          };
      }
    }
    
    if (error.request) {
      return {
        code: 'NETWORK_ERROR',
        message: 'Network error - Unable to reach server',
        retryable: true,
        action: 'Check network connectivity and try again'
      };
    }
    
    return {
      code: 'UNKNOWN_ERROR',
      message: error.message || 'Unknown error occurred',
      retryable: false,
      action: 'Check application logs and try again'
    };
  }

  static logError(error, context = {}) {
    const errorInfo = this.handleError(error, context);
    const logEntry = {
      timestamp: new Date().toISOString(),
      error: errorInfo,
      context,
      originalError: error.message
    };
    
    console.error('Flow Update Error:', JSON.stringify(logEntry, null, 2));
    
    // In production, send to logging service
    // await this.sendToLoggingService(logEntry);
    
    return errorInfo;
  }
}
```

### Monitoring and Metrics

```javascript
class FlowUpdateMonitor {
  constructor() {
    this.metrics = {
      totalUpdates: 0,
      successfulUpdates: 0,
      failedUpdates: 0,
      errorsByType: {},
      averageResponseTime: 0,
      lastUpdateTime: null
    };
  }

  recordUpdate(success, responseTime, errorType = null) {
    this.metrics.totalUpdates++;
    this.metrics.lastUpdateTime = Date.now();
    
    if (success) {
      this.metrics.successfulUpdates++;
    } else {
      this.metrics.failedUpdates++;
      if (errorType) {
        this.metrics.errorsByType[errorType] = (this.metrics.errorsByType[errorType] || 0) + 1;
      }
    }
    
    // Calculate average response time
    if (responseTime) {
      this.metrics.averageResponseTime = 
        (this.metrics.averageResponseTime * (this.metrics.totalUpdates - 1) + responseTime) / 
        this.metrics.totalUpdates;
    }
  }

  getMetrics() {
    return {
      ...this.metrics,
      successRate: this.metrics.totalUpdates > 0 ? 
        (this.metrics.successfulUpdates / this.metrics.totalUpdates * 100).toFixed(2) + '%' : 
        'N/A',
      failureRate: this.metrics.totalUpdates > 0 ? 
        (this.metrics.failedUpdates / this.metrics.totalUpdates * 100).toFixed(2) + '%' : 
        'N/A',
      lastUpdateTime: this.metrics.lastUpdateTime ? 
        new Date(this.metrics.lastUpdateTime).toISOString() : 
        'N/A'
    };
  }

  resetMetrics() {
    this.metrics = {
      totalUpdates: 0,
      successfulUpdates: 0,
      failedUpdates: 0,
      errorsByType: {},
      averageResponseTime: 0,
      lastUpdateTime: null
    };
  }

  generateReport() {
    const metrics = this.getMetrics();
    const report = {
      summary: {
        totalUpdates: metrics.totalUpdates,
        successRate: metrics.successRate,
        failureRate: metrics.failureRate,
        averageResponseTime: `${metrics.averageResponseTime.toFixed(2)}ms`,
        lastUpdate: metrics.lastUpdateTime
      },
      errorBreakdown: metrics.errorsByType,
      recommendations: this.generateRecommendations(metrics)
    };
    
    return report;
  }

  generateRecommendations(metrics) {
    const recommendations = [];
    
    if (metrics.failedUpdates > metrics.successfulUpdates) {
      recommendations.push('High failure rate detected - Review error logs and fix common issues');
    }
    
    if (metrics.errorsByType['FLOW_NOT_DRAFT'] > 0) {
      recommendations.push('Multiple flows not in Draft status - Implement flow status checks');
    }
    
    if (metrics.errorsByType['RATE_LIMITED'] > 0) {
      recommendations.push('Rate limiting detected - Implement request throttling');
    }
    
    if (metrics.averageResponseTime > 5000) {
      recommendations.push('High response times - Consider optimizing requests or checking network');
    }
    
    return recommendations;
  }
}
```

### Enhanced Flow Update Manager with Monitoring

```javascript
class MonitoredFlowUpdateManager extends AdvancedFlowUpdateManager {
  constructor(partnerAppToken) {
    super(partnerAppToken);
    this.monitor = new FlowUpdateMonitor();
    this.errorHandler = FlowUpdateErrorHandler;
  }

  async updateFlowWithMonitoring(appId, flowId, updateData) {
    const startTime = Date.now();
    const context = { appId, flowId, updateData };
    
    try {
      const result = await this.updateFlowWithValidation(appId, flowId, updateData);
      const responseTime = Date.now() - startTime;
      
      this.monitor.recordUpdate(true, responseTime);
      
      console.log(`Flow ${flowId} updated successfully in ${responseTime}ms`);
      return result;
    } catch (error) {
      const responseTime = Date.now() - startTime;
      const errorInfo = this.errorHandler.logError(error, context);
      
      this.monitor.recordUpdate(false, responseTime, errorInfo.code);
      
      throw error;
    }
  }

  // Get monitoring metrics
  getMonitoringMetrics() {
    return this.monitor.getMetrics();
  }

  // Generate monitoring report
  generateMonitoringReport() {
    return this.monitor.generateReport();
  }

  // Reset monitoring metrics
  resetMonitoring() {
    this.monitor.resetMetrics();
  }
}
```

### Health Check and Diagnostics

```javascript
class FlowUpdateHealthChecker {
  constructor(flowUpdateManager) {
    this.flowUpdateManager = flowUpdateManager;
  }

  async performHealthCheck(appId, testFlowId = null) {
    const healthReport = {
      timestamp: new Date().toISOString(),
      status: 'UNKNOWN',
      checks: {}
    };

    try {
      // Check API connectivity
      healthReport.checks.connectivity = await this.checkConnectivity();
      
      // Check authentication
      healthReport.checks.authentication = await this.checkAuthentication(appId);
      
      // Check flow operations (if test flow provided)
      if (testFlowId) {
        healthReport.checks.flowOperations = await this.checkFlowOperations(appId, testFlowId);
      }
      
      // Determine overall status
      const allChecks = Object.values(healthReport.checks);
      const allPassed = allChecks.every(check => check.status === 'PASS');
      const anyFailed = allChecks.some(check => check.status === 'FAIL');
      
      if (allPassed) {
        healthReport.status = 'HEALTHY';
      } else if (anyFailed) {
        healthReport.status = 'UNHEALTHY';
      } else {
        healthReport.status = 'DEGRADED';
      }
      
    } catch (error) {
      healthReport.status = 'UNHEALTHY';
      healthReport.error = error.message;
    }

    return healthReport;
  }

  async checkConnectivity() {
    try {
      const response = await fetch('https://partner.gupshup.io/health', {
        method: 'GET',
        timeout: 5000
      });
      
      return {
        status: response.ok ? 'PASS' : 'FAIL',
        responseTime: Date.now(),
        message: response.ok ? 'API endpoint reachable' : 'API endpoint not reachable'
      };
    } catch (error) {
      return {
        status: 'FAIL',
        message: `Connectivity check failed: ${error.message}`
      };
    }
  }

  async checkAuthentication(appId) {
    try {
      // Try to get flows list to test authentication
      const response = await fetch(`https://partner.gupshup.io/partner/app/${appId}/flows`, {
        method: 'GET',
        headers: {
          'Authorization': this.flowUpdateManager.partnerAppToken,
          'Content-Type': 'application/json'
        }
      });
      
      return {
        status: response.status === 401 ? 'FAIL' : 'PASS',
        message: response.status === 401 ? 'Authentication failed' : 'Authentication successful'
      };
    } catch (error) {
      return {
        status: 'FAIL',
        message: `Authentication check failed: ${error.message}`
      };
    }
  }

  async checkFlowOperations(appId, flowId) {
    try {
      // Try to get flow details to test flow operations
      const currentData = await this.flowUpdateManager.getCurrentFlowData(appId, flowId);
      
      return {
        status: 'PASS',
        message: 'Flow operations working correctly',
        flowStatus: currentData.status,
        flowName: currentData.name
      };
    } catch (error) {
      return {
        status: 'FAIL',
        message: `Flow operations check failed: ${error.message}`
      };
    }
  }

  async runDiagnostics(appId, flowId) {
    const diagnostics = {
      timestamp: new Date().toISOString(),
      appId,
      flowId,
      checks: {}
    };

    try {
      // Check flow exists
      diagnostics.checks.flowExists = await this.checkFlowExists(appId, flowId);
      
      // Check flow status
      diagnostics.checks.flowStatus = await this.checkFlowStatus(appId, flowId);
      
      // Check flow data validity
      diagnostics.checks.dataValidity = await this.checkFlowDataValidity(appId, flowId);
      
      // Check permissions
      diagnostics.checks.permissions = await this.checkPermissions(appId, flowId);
      
    } catch (error) {
      diagnostics.error = error.message;
    }

    return diagnostics;
  }

  async checkFlowExists(appId, flowId) {
    try {
      await this.flowUpdateManager.getCurrentFlowData(appId, flowId);
      return { status: 'PASS', message: 'Flow exists' };
    } catch (error) {
      return { status: 'FAIL', message: `Flow not found: ${error.message}` };
    }
  }

  async checkFlowStatus(appId, flowId) {
    try {
      const flowData = await this.flowUpdateManager.getCurrentFlowData(appId, flowId);
      const isDraft = flowData.status === 'DRAFT';
      
      return {
        status: 'PASS',
        message: `Flow status: ${flowData.status}`,
        isDraft,
        canUpdate: isDraft
      };
    } catch (error) {
      return { status: 'FAIL', message: `Cannot check flow status: ${error.message}` };
    }
  }

  async checkFlowDataValidity(appId, flowId) {
    try {
      const flowData = await this.flowUpdateManager.getCurrentFlowData(appId, flowId);
      const validationErrors = this.flowUpdateManager.validateUpdateData(flowData);
      
      return {
        status: validationErrors.length === 0 ? 'PASS' : 'FAIL',
        message: validationErrors.length === 0 ? 'Flow data is valid' : 'Flow data has issues',
        errors: validationErrors
      };
    } catch (error) {
      return { status: 'FAIL', message: `Cannot validate flow data: ${error.message}` };
    }
  }

  async checkPermissions(appId, flowId) {
    try {
      // Try to perform a read operation to check permissions
      await this.flowUpdateManager.getCurrentFlowData(appId, flowId);
      return { status: 'PASS', message: 'Permissions are adequate' };
    } catch (error) {
      const is403 = error.response?.status === 403;
      return {
        status: is403 ? 'FAIL' : 'PASS',
        message: is403 ? 'Insufficient permissions' : 'Permissions check passed'
      };
    }
  }
}
```

### Usage Example with Full Monitoring

```javascript
async function demonstrateMonitoringCapabilities() {
  try {
    // Create monitored flow update manager
    const flowManager = new MonitoredFlowUpdateManager('YOUR_PARTNER_APP_TOKEN');
    
    // Create health checker
    const healthChecker = new FlowUpdateHealthChecker(flowManager);
    
    // Perform health check
    const healthReport = await healthChecker.performHealthCheck('YOUR_APP_ID', 'YOUR_FLOW_ID');
    console.log('Health Report:', JSON.stringify(healthReport, null, 2));
    
    // Update flow with monitoring
    const updateData = {
      name: 'Monitored Flow Update',
      categories: ['SUPPORT', 'FAQ']
    };
    
    await flowManager.updateFlowWithMonitoring('YOUR_APP_ID', 'YOUR_FLOW_ID', updateData);
    
    // Get monitoring metrics
    const metrics = flowManager.getMonitoringMetrics();
    console.log('Monitoring Metrics:', metrics);
    
    // Generate monitoring report
    const report = flowManager.generateMonitoringReport();
    console.log('Monitoring Report:', JSON.stringify(report, null, 2));
    
    // Run diagnostics
    const diagnostics = await healthChecker.runDiagnostics('YOUR_APP_ID', 'YOUR_FLOW_ID');
    console.log('Diagnostics:', JSON.stringify(diagnostics, null, 2));
    
  } catch (error) {
    console.error('Monitoring demonstration failed:', error);
  }
}
```

## Security and Rate Limiting

### Rate Limiting Implementation

```javascript
class RateLimitedFlowUpdateManager {
  constructor(partnerAppToken, rateLimitConfig = {}) {
    this.partnerAppToken = partnerAppToken;
    this.baseURL = 'https://partner.gupshup.io/partner/app';
    
    // Rate limiting configuration
    this.rateLimit = {
      requestsPerMinute: rateLimitConfig.requestsPerMinute || 60,
      requestsPerHour: rateLimitConfig.requestsPerHour || 1000,
      burstLimit: rateLimitConfig.burstLimit || 10
    };
    
    // Request tracking
    this.requestHistory = [];
    this.requestQueue = [];
    this.processing = false;
  }

  async updateFlowWithRateLimit(appId, flowId, updateData) {
    return new Promise((resolve, reject) => {
      this.requestQueue.push({
        appId,
        flowId,
        updateData,
        resolve,
        reject,
        timestamp: Date.now()
      });
      
      this.processQueue();
    });
  }

  async processQueue() {
    if (this.processing || this.requestQueue.length === 0) {
      return;
    }
    
    this.processing = true;
    
    while (this.requestQueue.length > 0) {
      const canMakeRequest = this.checkRateLimit();
      
      if (!canMakeRequest) {
        const delay = this.calculateDelay();
        console.log(`Rate limit reached. Waiting ${delay}ms...`);
        await this.sleep(delay);
        continue;
      }
      
      const request = this.requestQueue.shift();
      
      try {
        this.recordRequest();
        const result = await this.performUpdate(request.appId, request.flowId, request.updateData);
        request.resolve(result);
      } catch (error) {
        request.reject(error);
      }
    }
    
    this.processing = false;
  }

  checkRateLimit() {
    const now = Date.now();
    const oneMinuteAgo = now - 60000;
    const oneHourAgo = now - 3600000;
    
    // Clean old requests
    this.requestHistory = this.requestHistory.filter(timestamp => timestamp > oneHourAgo);
    
    const requestsInLastMinute = this.requestHistory.filter(timestamp => timestamp > oneMinuteAgo).length;
    const requestsInLastHour = this.requestHistory.length;
    
    return requestsInLastMinute < this.rateLimit.requestsPerMinute && 
           requestsInLastHour < this.rateLimit.requestsPerHour;
  }

  recordRequest() {
    this.requestHistory.push(Date.now());
  }

  calculateDelay() {
    const now = Date.now();
    const oneMinuteAgo = now - 60000;
    const recentRequests = this.requestHistory.filter(timestamp => timestamp > oneMinuteAgo);
    
    if (recentRequests.length >= this.rateLimit.requestsPerMinute) {
      const oldestRequest = Math.min(...recentRequests);
      return Math.max(0, 60000 - (now - oldestRequest));
    }
    
    return 1000; // Default delay
  }

  async performUpdate(appId, flowId, updateData) {
    const response = await fetch(`${this.baseURL}/${appId}/flows/${flowId}`, {
      method: 'PUT',
      headers: {
        'Authorization': this.partnerAppToken,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(updateData)
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    return await response.json();
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  getRateLimitStatus() {
    const now = Date.now();
    const oneMinuteAgo = now - 60000;
    const oneHourAgo = now - 3600000;
    
    const requestsInLastMinute = this.requestHistory.filter(timestamp => timestamp > oneMinuteAgo).length;
    const requestsInLastHour = this.requestHistory.filter(timestamp => timestamp > oneHourAgo).length;
    
    return {
      requestsPerMinute: {
        current: requestsInLastMinute,
        limit: this.rateLimit.requestsPerMinute,
        remaining: Math.max(0, this.rateLimit.requestsPerMinute - requestsInLastMinute)
      },
      requestsPerHour: {
        current: requestsInLastHour,
        limit: this.rateLimit.requestsPerHour,
        remaining: Math.max(0, this.rateLimit.requestsPerHour - requestsInLastHour)
      },
      queueSize: this.requestQueue.length
    };
  }
}
```

### Security Best Practices

```javascript
class SecureFlowUpdateManager {
  constructor(config) {
    this.config = this.validateConfig(config);
    this.tokenManager = new TokenManager(config.tokenConfig);
    this.auditLogger = new AuditLogger(config.auditConfig);
  }

  validateConfig(config) {
    const required = ['partnerAppToken', 'appId'];
    const missing = required.filter(field => !config[field]);
    
    if (missing.length > 0) {
      throw new Error(`Missing required configuration: ${missing.join(', ')}`);
    }
    
    return config;
  }

  async updateFlowSecurely(appId, flowId, updateData, userContext = {}) {
    try {
      // Validate input
      this.validateInput(appId, flowId, updateData);
      
      // Check permissions
      await this.checkPermissions(appId, flowId, userContext);
      
      // Sanitize data
      const sanitizedData = this.sanitizeUpdateData(updateData);
      
      // Perform update
      const result = await this.performSecureUpdate(appId, flowId, sanitizedData);
      
      // Log audit trail
      await this.auditLogger.logUpdate(appId, flowId, sanitizedData, result, userContext);
      
      return result;
    } catch (error) {
      await this.auditLogger.logError(appId, flowId, updateData, error, userContext);
      throw error;
    }
  }

  validateInput(appId, flowId, updateData) {
    // Validate app ID format
    if (!/^[a-zA-Z0-9-_]{1,50}$/.test(appId)) {
      throw new Error('Invalid app ID format');
    }
    
    // Validate flow ID format
    if (!/^[a-zA-Z0-9-_]{1,100}$/.test(flowId)) {
      throw new Error('Invalid flow ID format');
    }
    
    // Validate update data
    if (!updateData || typeof updateData !== 'object') {
      throw new Error('Update data must be an object');
    }
    
    // Validate name
    if (!updateData.name || typeof updateData.name !== 'string') {
      throw new Error('Flow name is required and must be a string');
    }
    
    if (updateData.name.length > 100) {
      throw new Error('Flow name must be 100 characters or less');
    }
    
    // Validate categories
    if (!Array.isArray(updateData.categories)) {
      throw new Error('Categories must be an array');
    }
    
    if (updateData.categories.length === 0) {
      throw new Error('At least one category is required');
    }
  }

  sanitizeUpdateData(updateData) {
    return {
      name: updateData.name.trim().replace(/[<>]/g, ''),
      categories: updateData.categories.map(cat => cat.trim().toUpperCase())
    };
  }

  async checkPermissions(appId, flowId, userContext) {
    // Implement permission checking logic
    // This would typically involve checking user roles, app permissions, etc.
    if (userContext.role === 'readonly') {
      throw new Error('Insufficient permissions to update flow');
    }
    
    // Additional permission checks...
  }

  async performSecureUpdate(appId, flowId, updateData) {
    const token = await this.tokenManager.getValidToken();
    
    const response = await fetch(`https://partner.gupshup.io/partner/app/${appId}/flows/${flowId}`, {
      method: 'PUT',
      headers: {
        'Authorization': token,
        'Content-Type': 'application/json',
        'X-Request-ID': this.generateRequestId()
      },
      body: JSON.stringify(updateData)
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    return await response.json();
  }

  generateRequestId() {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

class TokenManager {
  constructor(config) {
    this.config = config;
    this.tokenCache = new Map();
  }

  async getValidToken() {
    const cachedToken = this.tokenCache.get('current');
    
    if (cachedToken && this.isTokenValid(cachedToken)) {
      return cachedToken.token;
    }
    
    const newToken = await this.refreshToken();
    this.tokenCache.set('current', newToken);
    
    return newToken.token;
  }

  isTokenValid(tokenData) {
    return tokenData.expiresAt > Date.now() + 60000; // 1 minute buffer
  }

  async refreshToken() {
    // Implement token refresh logic
    // This would typically involve calling a token refresh endpoint
    return {
      token: this.config.partnerAppToken,
      expiresAt: Date.now() + 3600000 // 1 hour
    };
  }
}

class AuditLogger {
  constructor(config) {
    this.config = config;
  }

  async logUpdate(appId, flowId, updateData, result, userContext) {
    const auditEntry = {
      timestamp: new Date().toISOString(),
      action: 'FLOW_UPDATE',
      appId,
      flowId,
      updateData,
      result,
      userContext,
      success: true
    };

    await this.writeAuditLog(auditEntry);
  }

  async logError(appId, flowId, updateData, error, userContext) {
    const auditEntry = {
      timestamp: new Date().toISOString(),
      action: 'FLOW_UPDATE',
      appId,
      flowId,
      updateData,
      error: error.message,
      userContext,
      success: false
    };

    await this.writeAuditLog(auditEntry);
  }

  async writeAuditLog(entry) {
    // In production, this would write to a secure audit log
    console.log('AUDIT LOG:', JSON.stringify(entry, null, 2));
  }
}
```