# Gupshup Partner API - Publish Flow

## Overview
The Publish Flow API allows you to publish a flow that is currently in draft state. This endpoint is used to make draft flows live and available for use.

## Endpoint Details

**URL:** `https://partner.gupshup.io/partner/app/{appId}/flows/{flowId}/publish`  
**Method:** `POST`  
**Content-Type:** `application/json`

## Request Parameters

| Parameter | Description | Example | Type | Required | Notes |
|-----------|-------------|---------|------|----------|-------|
| Authorization | Access Token for the application | `{{PARTNER_APP_TOKEN}}` | String | Required | Should be a valid Partner App Access Token |
| appId | App id of the app | `{{APP_ID}}` | String | Required | The Id should be a valid app Id of Gupshup |
| flowId | Flow Id | `{{FLOW_ID}}` | String | Required | Flow Id generated by Meta |

## Sample cURL Request

```bash
curl --location --globoff --request POST 'https://partner.gupshup.io/partner/app/{{APP_ID}}/flows/{{FLOW_ID}}/publish' \
--header 'Authorization: {{PARTNER_APP_TOKEN}}' \
--header 'Content-Type: application/json'
```

## Sample Response

### Success Response
```json
{
    "status": "success",
    "success": true
}
```

## Status Codes

| Code | Response | Description |
|------|----------|-------------|
| 200 | `{ "status": "success", "success": true }` | Successfully publish a flow |
| 400 | `{ "status": "error", "message": "Flow cannot be published as it's not in DRAFT state" }` | For publishing a flow that is not in draft state |

## Node.js Code Examples

### Basic Flow Publishing

```javascript
const axios = require('axios');

async function publishFlow(appId, flowId, token) {
    try {
        const response = await axios.post(
            `https://partner.gupshup.io/partner/app/${appId}/flows/${flowId}/publish`,
            {},
            {
                headers: {
                    'Authorization': token,
                    'Content-Type': 'application/json'
                }
            }
        );
        
        return response.data;
    } catch (error) {
        console.error('Error publishing flow:', error.response?.data || error.message);
        throw error;
    }
}

// Usage
const appId = 'your-app-id';
const flowId = 'your-flow-id';
const token = 'your-partner-token';

publishFlow(appId, flowId, token)
    .then(result => {
        console.log('Flow published successfully:', result);
    })
    .catch(error => {
        console.error('Failed to publish flow:', error);
    });
```

### With Enhanced Error Handling

```javascript
const axios = require('axios');

async function publishFlowWithErrorHandling(appId, flowId, token) {
    try {
        const response = await axios.post(
            `https://partner.gupshup.io/partner/app/${appId}/flows/${flowId}/publish`,
            {},
            {
                headers: {
                    'Authorization': token,
                    'Content-Type': 'application/json'
                },
                timeout: 10000 // 10 seconds timeout
            }
        );
        
        if (response.data.success) {
            return {
                success: true,
                message: 'Flow published successfully',
                data: response.data
            };
        } else {
            return {
                success: false,
                message: 'Failed to publish flow',
                error: response.data
            };
        }
    } catch (error) {
        if (error.response) {
            // Server responded with error status
            const errorMessage = error.response.data?.message || 'Unknown server error';
            return {
                success: false,
                message: errorMessage,
                statusCode: error.response.status,
                error: error.response.data
            };
        } else if (error.request) {
            // Request was made but no response received
            return {
                success: false,
                message: 'No response received from server',
                error: 'Network error'
            };
        } else {
            // Something else happened
            return {
                success: false,
                message: 'Request setup error',
                error: error.message
            };
        }
    }
}

// Usage
publishFlowWithErrorHandling(appId, flowId, token)
    .then(result => {
        if (result.success) {
            console.log('✅ Flow published successfully:', result.data);
        } else {
            console.error('❌ Failed to publish flow:', result.message);
        }
    });
```

### Complete Flow Publishing Manager

```javascript
const axios = require('axios');

class FlowPublishingManager {
    constructor(baseURL = 'https://partner.gupshup.io/partner', timeout = 10000) {
        this.baseURL = baseURL;
        this.timeout = timeout;
        this.axiosInstance = axios.create({
            baseURL: this.baseURL,
            timeout: this.timeout,
            headers: {
                'Content-Type': 'application/json'
            }
        });
    }

    async publishFlow(appId, flowId, token) {
        try {
            const response = await this.axiosInstance.post(
                `/app/${appId}/flows/${flowId}/publish`,
                {},
                {
                    headers: {
                        'Authorization': token
                    }
                }
            );
            
            return {
                success: true,
                data: response.data,
                timestamp: new Date().toISOString()
            };
        } catch (error) {
            throw this.handleError(error);
        }
    }

    async publishFlowWithValidation(appId, flowId, token) {
        // Validate input parameters
        if (!appId || !flowId || !token) {
            throw new Error('Missing required parameters: appId, flowId, and token are required');
        }

        try {
            const result = await this.publishFlow(appId, flowId, token);
            
            // Log successful publication
            this.logActivity('PUBLISH_SUCCESS', {
                appId,
                flowId,
                timestamp: result.timestamp
            });
            
            return result;
        } catch (error) {
            // Log failed publication
            this.logActivity('PUBLISH_FAILED', {
                appId,
                flowId,
                error: error.message,
                timestamp: new Date().toISOString()
            });
            
            throw error;
        }
    }

    async publishMultipleFlows(appId, flowIds, token) {
        const results = [];
        
        for (const flowId of flowIds) {
            try {
                const result = await this.publishFlow(appId, flowId, token);
                results.push({
                    flowId,
                    success: true,
                    result: result.data
                });
            } catch (error) {
                results.push({
                    flowId,
                    success: false,
                    error: error.message
                });
            }
        }
        
        return results;
    }

    async publishFlowWithRetry(appId, flowId, token, maxRetries = 3) {
        let lastError;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const result = await this.publishFlow(appId, flowId, token);
                
                if (attempt > 1) {
                    console.log(`✅ Flow published successfully on attempt ${attempt}`);
                }
                
                return result;
            } catch (error) {
                lastError = error;
                
                if (attempt < maxRetries) {
                    const delay = Math.pow(2, attempt) * 1000; // Exponential backoff
                    console.log(`❌ Attempt ${attempt} failed, retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                } else {
                    console.log(`❌ All ${maxRetries} attempts failed`);
                }
            }
        }
        
        throw lastError;
    }

    handleError(error) {
        if (error.response) {
            const { status, data } = error.response;
            
            switch (status) {
                case 400:
                    return new Error(data.message || 'Flow cannot be published - not in DRAFT state');
                case 401:
                    return new Error('Unauthorized - Invalid or expired token');
                case 403:
                    return new Error('Forbidden - Insufficient permissions');
                case 404:
                    return new Error('Flow not found');
                case 429:
                    return new Error('Rate limit exceeded');
                case 500:
                    return new Error('Internal server error');
                default:
                    return new Error(`HTTP ${status}: ${data.message || 'Unknown error'}`);
            }
        } else if (error.request) {
            return new Error('Network error - No response received');
        } else {
            return new Error(`Request error: ${error.message}`);
        }
    }

    logActivity(action, details) {
        const logEntry = {
            action,
            timestamp: new Date().toISOString(),
            ...details
        };
        
        console.log(`[${action}]`, logEntry);
        
        // You can extend this to write to a file, database, or external logging service
    }

    // Utility method to check if flow is in draft state before publishing
    async isFlowInDraftState(appId, flowId, token) {
        try {
            // This would require implementing the get flow details API
            // For now, we'll return a placeholder
            return true;
        } catch (error) {
            console.warn('Could not verify flow state:', error.message);
            return false;
        }
    }
}

// Usage Examples
const flowManager = new FlowPublishingManager();

// Basic usage
async function example1() {
    const appId = 'your-app-id';
    const flowId = 'your-flow-id';
    const token = 'your-partner-token';
    
    try {
        const result = await flowManager.publishFlow(appId, flowId, token);
        console.log('Flow published:', result);
    } catch (error) {
        console.error('Error:', error.message);
    }
}

// With validation
async function example2() {
    const appId = 'your-app-id';
    const flowId = 'your-flow-id';
    const token = 'your-partner-token';
    
    try {
        const result = await flowManager.publishFlowWithValidation(appId, flowId, token);
        console.log('Flow published with validation:', result);
    } catch (error) {
        console.error('Validation error:', error.message);
    }
}

// Publish multiple flows
async function example3() {
    const appId = 'your-app-id';
    const flowIds = ['flow1', 'flow2', 'flow3'];
    const token = 'your-partner-token';
    
    try {
        const results = await flowManager.publishMultipleFlows(appId, flowIds, token);
        console.log('Multiple flows published:', results);
    } catch (error) {
        console.error('Error:', error.message);
    }
}

// With retry logic
async function example4() {
    const appId = 'your-app-id';
    const flowId = 'your-flow-id';
    const token = 'your-partner-token';
    
    try {
        const result = await flowManager.publishFlowWithRetry(appId, flowId, token, 3);
        console.log('Flow published with retry:', result);
    } catch (error) {
        console.error('Final error after retries:', error.message);
    }
}
```

### Integration with Flow Management Pipeline

```javascript
// Advanced flow publishing with pipeline integration
class FlowPublishingPipeline {
    constructor(flowManager) {
        this.flowManager = flowManager;
        this.publishingQueue = [];
        this.isProcessing = false;
    }

    async addToPublishingQueue(appId, flowId, token, priority = 'normal') {
        const item = {
            appId,
            flowId,
            token,
            priority,
            timestamp: Date.now(),
            id: `${appId}-${flowId}-${Date.now()}`
        };

        this.publishingQueue.push(item);
        this.sortQueue();
        
        if (!this.isProcessing) {
            this.processQueue();
        }
        
        return item.id;
    }

    sortQueue() {
        this.publishingQueue.sort((a, b) => {
            // Priority: high > normal > low
            const priorityOrder = { high: 3, normal: 2, low: 1 };
            if (priorityOrder[a.priority] !== priorityOrder[b.priority]) {
                return priorityOrder[b.priority] - priorityOrder[a.priority];
            }
            // If same priority, sort by timestamp (FIFO)
            return a.timestamp - b.timestamp;
        });
    }

    async processQueue() {
        if (this.isProcessing || this.publishingQueue.length === 0) {
            return;
        }

        this.isProcessing = true;
        
        while (this.publishingQueue.length > 0) {
            const item = this.publishingQueue.shift();
            
            try {
                console.log(`Processing publication: ${item.id}`);
                
                await this.flowManager.publishFlowWithRetry(
                    item.appId,
                    item.flowId,
                    item.token,
                    3
                );
                
                console.log(`✅ Published flow ${item.flowId} successfully`);
            } catch (error) {
                console.error(`❌ Failed to publish flow ${item.flowId}:`, error.message);
                
                // Optionally add to dead letter queue or retry later
                this.handleFailedPublication(item, error);
            }
            
            // Add delay between publications to avoid rate limiting
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        this.isProcessing = false;
    }

    handleFailedPublication(item, error) {
        // Log failure or add to dead letter queue
        console.log(`Failed publication logged: ${item.id} - ${error.message}`);
    }

    getQueueStatus() {
        return {
            queueLength: this.publishingQueue.length,
            isProcessing: this.isProcessing,
            nextItems: this.publishingQueue.slice(0, 5).map(item => ({
                id: item.id,
                flowId: item.flowId,
                priority: item.priority
            }))
        };
    }
}

// Usage
const flowManager = new FlowPublishingManager();
const pipeline = new FlowPublishingPipeline(flowManager);

// Add flows to publishing queue
pipeline.addToPublishingQueue('app1', 'flow1', 'token1', 'high');
pipeline.addToPublishingQueue('app1', 'flow2', 'token1', 'normal');
pipeline.addToPublishingQueue('app1', 'flow3', 'token1', 'low');

// Check queue status
console.log('Queue status:', pipeline.getQueueStatus());
```

## Best Practices

### 1. Flow State Validation
- Always verify that the flow is in DRAFT state before attempting to publish
- Handle the specific error when flow is not in draft state

### 2. Error Handling
- Implement proper error handling for network issues and API errors
- Use retry logic with exponential backoff for transient failures

### 3. Logging and Monitoring
- Log all publish attempts and their outcomes
- Monitor publishing success rates and failure patterns

### 4. Batch Operations
- When publishing multiple flows, implement batching with delays to avoid rate limiting
- Consider using a queue system for managing multiple publications

### 5. Security
- Never log or store authentication tokens
- Implement token rotation and validation

## Common Use Cases

1. **Automated Publishing**: Automatically publish flows after successful testing
2. **Bulk Publishing**: Publish multiple flows in a controlled manner
3. **Scheduled Publishing**: Implement scheduling for flow publications
4. **Pipeline Integration**: Integrate with CI/CD pipelines for automated flow deployment

## Important Notes

- Flows must be in DRAFT state to be published
- Once published, flows cannot be directly edited - they need to be updated through the flow update API
- Publishing is irreversible - ensure flows are properly tested before publishing
- Monitor for rate limiting when publishing multiple flows in succession

## Error Handling Examples

```javascript
// Handle specific publishing errors
try {
    await flowManager.publishFlow(appId, flowId, token);
} catch (error) {
    if (error.message.includes('not in DRAFT state')) {
        console.log('Flow is already published or in wrong state');
        // Handle already published flow
    } else if (error.message.includes('Unauthorized')) {
        console.log('Token expired or invalid');
        // Handle token refresh
    } else {
        console.log('Unexpected error:', error.message);
        // Handle other errors
    }
}
```

This comprehensive documentation covers all aspects of the Gupshup Partner API Publish Flow endpoint, including detailed Node.js examples, error handling, and best practices for production use.
