# Gupshup Publish Flow API

## Overview
The Publish Flow API allows you to publish a flow that is currently in DRAFT status, making it live and available for use. Once published, the flow becomes active and can be used by end users through WhatsApp Business messaging.

## Base URL
```
https://partner.gupshup.io/partner/app/{appId}/flows/{flowId}/publish
```

## Authentication
- **Method**: Bearer Token
- **Header**: `Authorization: {PARTNER_APP_TOKEN}`

## Endpoint

### Publish Flow
**POST** `/partner/app/{appId}/flows/{flowId}/publish`

Publishes a flow that is currently in DRAFT status.

#### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| Authorization | String | Yes | Access Token for the application |
| appId | String | Yes | App ID of the application |
| flowId | String | Yes | Flow ID generated by Meta |

#### Sample cURL Request
```bash
curl --location --globoff --request POST 'https://partner.gupshup.io/partner/app/{{APP_ID}}/flows/{{FLOW_ID}}/publish' \
--header 'Authorization: {{PARTNER_APP_TOKEN}}' \
--header 'Content-Type: application/json'
```

**Real Example:**
```bash
curl --location --globoff --request POST 'https://partner.gupshup.io/partner/app/YOUR_APP_ID/flows/YOUR_FLOW_ID/publish' \
--header 'Authorization: YOUR_PARTNER_APP_TOKEN' \
--header 'Content-Type: application/json'
```

#### Sample Response
```json
{
    "status": "success",
    "success": true
}
```

#### Status Codes

| Status | Response | Description |
|--------|----------|-------------|
| 200 | `{ "status": "success", "success": true }` | Successfully publish a flow |
| 400 | `{ "status": "error", "message": "Flow cannot be published as it's not in DRAFT state" }` | For publishing a flow that is not in draft state |
| 401 | `{ "status": "error", "message": "Unauthorized" }` | Invalid or missing authorization token |
| 404 | `{ "status": "error", "message": "Flow not found" }` | Flow ID not found |

## Node.js Examples

### Basic Publish Flow
```javascript
const https = require('https');

async function publishFlow(appId, flowId, partnerToken) {
    const options = {
        hostname: 'partner.gupshup.io',
        port: 443,
        path: `/partner/app/${appId}/flows/${flowId}/publish`,
        method: 'POST',
        headers: {
            'Authorization': partnerToken,
            'Content-Type': 'application/json'
        }
    };

    return new Promise((resolve, reject) => {
        const req = https.request(options, (res) => {
            let responseData = '';
            
            res.on('data', (chunk) => {
                responseData += chunk;
            });
            
            res.on('end', () => {
                try {
                    const parsedData = JSON.parse(responseData);
                    resolve(parsedData);
                } catch (error) {
                    reject(new Error('Invalid JSON response'));
                }
            });
        });

        req.on('error', (error) => {
            reject(error);
        });

        req.end();
    });
}

// Usage
publishFlow('your-app-id', 'your-flow-id', 'your-partner-token')
    .then(response => {
        console.log('Flow published successfully:', response);
    })
    .catch(error => {
        console.error('Error publishing flow:', error);
    });
```

### Advanced Flow Publisher
```javascript
const fetch = require('node-fetch');

class FlowPublisher {
    constructor(baseUrl, partnerToken) {
        this.baseUrl = baseUrl || 'https://partner.gupshup.io';
        this.partnerToken = partnerToken;
    }

    async publishFlow(appId, flowId) {
        const url = `${this.baseUrl}/partner/app/${appId}/flows/${flowId}/publish`;
        
        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Authorization': this.partnerToken,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`HTTP error! status: ${response.status}, message: ${errorData.message}`);
            }

            return await response.json();
        } catch (error) {
            throw new Error(`Failed to publish flow: ${error.message}`);
        }
    }

    async publishFlowWithValidation(appId, flowId) {
        try {
            // First, check if flow is in DRAFT status
            const flowStatus = await this.getFlowStatus(appId, flowId);
            
            if (flowStatus !== 'DRAFT') {
                throw new Error(`Flow is not in DRAFT status. Current status: ${flowStatus}`);
            }

            // Publish the flow
            const result = await this.publishFlow(appId, flowId);
            
            console.log(`Flow ${flowId} published successfully`);
            return result;
        } catch (error) {
            console.error(`Failed to publish flow ${flowId}:`, error.message);
            throw error;
        }
    }

    async getFlowStatus(appId, flowId) {
        // This would use the Get Flow API to check status
        // For now, return a placeholder
        try {
            const response = await fetch(`${this.baseUrl}/partner/app/${appId}/flows/${flowId}`, {
                method: 'GET',
                headers: {
                    'Authorization': this.partnerToken,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`Failed to get flow status: ${response.status}`);
            }

            const flowData = await response.json();
            return flowData.status;
        } catch (error) {
            throw new Error(`Unable to verify flow status: ${error.message}`);
        }
    }

    async publishFlowWithRetry(appId, flowId, maxRetries = 3) {
        let lastError;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                console.log(`Publishing flow attempt ${attempt}/${maxRetries}`);
                const result = await this.publishFlowWithValidation(appId, flowId);
                console.log('Flow published successfully on attempt', attempt);
                return result;
            } catch (error) {
                lastError = error;
                console.error(`Attempt ${attempt} failed:`, error.message);
                
                if (attempt < maxRetries) {
                    const delay = Math.pow(2, attempt) * 1000; // Exponential backoff
                    console.log(`Retrying in ${delay}ms...`);
                    await this.sleep(delay);
                }
            }
        }
        
        throw new Error(`Failed to publish flow after ${maxRetries} attempts. Last error: ${lastError.message}`);
    }

    async publishMultipleFlows(flows) {
        const results = [];
        
        for (const { appId, flowId } of flows) {
            try {
                const result = await this.publishFlowWithValidation(appId, flowId);
                results.push({
                    appId,
                    flowId,
                    success: true,
                    result
                });
            } catch (error) {
                results.push({
                    appId,
                    flowId,
                    success: false,
                    error: error.message
                });
            }
        }
        
        return results;
    }

    async scheduleFlowPublication(appId, flowId, publishTime) {
        const now = new Date();
        const targetTime = new Date(publishTime);
        
        if (targetTime <= now) {
            throw new Error('Publish time must be in the future');
        }
        
        const delay = targetTime - now;
        
        console.log(`Flow ${flowId} scheduled for publication at ${targetTime.toISOString()}`);
        
        setTimeout(async () => {
            try {
                await this.publishFlowWithValidation(appId, flowId);
                console.log(`Scheduled publication completed for flow ${flowId}`);
            } catch (error) {
                console.error(`Scheduled publication failed for flow ${flowId}:`, error.message);
            }
        }, delay);
        
        return {
            flowId,
            scheduledFor: targetTime.toISOString(),
            delay: `${Math.floor(delay / 1000)} seconds`
        };
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// Usage
const flowPublisher = new FlowPublisher('https://partner.gupshup.io', 'your-partner-token');

// Publish single flow with validation
flowPublisher.publishFlowWithValidation('your-app-id', 'your-flow-id')
    .then(result => {
        console.log('Flow published:', result);
    })
    .catch(error => {
        console.error('Error:', error.message);
    });

// Publish multiple flows
const flows = [
    { appId: 'app1', flowId: 'flow1' },
    { appId: 'app1', flowId: 'flow2' }
];

flowPublisher.publishMultipleFlows(flows)
    .then(results => {
        console.log('Batch publication results:', results);
    })
    .catch(error => {
        console.error('Batch error:', error);
    });
```

### Comprehensive Flow Publication Manager
```javascript
const axios = require('axios');

class FlowPublicationManager {
    constructor(baseUrl, partnerToken) {
        this.baseUrl = baseUrl || 'https://partner.gupshup.io';
        this.partnerToken = partnerToken;
        this.publicationHistory = new Map();
        this.pendingPublications = new Map();
    }

    async publishFlow(appId, flowId, options = {}) {
        const {
            validateBefore = true,
            createBackup = false,
            notifyOnSuccess = false,
            retryOnFailure = true
        } = options;

        try {
            // Pre-publication validation
            if (validateBefore) {
                await this.validateFlowForPublication(appId, flowId);
            }

            // Create backup if requested
            if (createBackup) {
                await this.createPublicationBackup(appId, flowId);
            }

            // Publish the flow
            const result = await this.performPublication(appId, flowId);

            // Record publication
            this.recordPublication(appId, flowId, result, 'success');

            // Post-publication actions
            if (notifyOnSuccess) {
                await this.sendPublicationNotification(appId, flowId, 'success', result);
            }

            return result;
        } catch (error) {
            this.recordPublication(appId, flowId, null, 'failed', error.message);
            
            if (retryOnFailure) {
                return await this.retryPublication(appId, flowId, options);
            }
            
            throw error;
        }
    }

    async validateFlowForPublication(appId, flowId) {
        const validationResults = {
            statusCheck: false,
            contentValidation: false,
            routingValidation: false,
            errors: []
        };

        try {
            // Check flow status
            const flowStatus = await this.getFlowStatus(appId, flowId);
            if (flowStatus !== 'DRAFT') {
                validationResults.errors.push(`Flow is not in DRAFT status: ${flowStatus}`);
            } else {
                validationResults.statusCheck = true;
            }

            // Validate flow content
            const contentValidation = await this.validateFlowContent(appId, flowId);
            validationResults.contentValidation = contentValidation.valid;
            if (!contentValidation.valid) {
                validationResults.errors.push(...contentValidation.errors);
            }

            // Validate routing
            const routingValidation = await this.validateFlowRouting(appId, flowId);
            validationResults.routingValidation = routingValidation.valid;
            if (!routingValidation.valid) {
                validationResults.errors.push(...routingValidation.errors);
            }

            if (validationResults.errors.length > 0) {
                throw new Error(`Validation failed: ${validationResults.errors.join(', ')}`);
            }

            return validationResults;
        } catch (error) {
            throw new Error(`Pre-publication validation failed: ${error.message}`);
        }
    }

    async getFlowStatus(appId, flowId) {
        try {
            const response = await axios.get(`${this.baseUrl}/partner/app/${appId}/flows/${flowId}`, {
                headers: {
                    'Authorization': this.partnerToken,
                    'Content-Type': 'application/json'
                }
            });

            return response.data.status;
        } catch (error) {
            throw new Error(`Failed to get flow status: ${error.message}`);
        }
    }

    async validateFlowContent(appId, flowId) {
        // This would validate the flow's content structure
        // For now, return a basic validation
        try {
            const flowData = await this.getFlowData(appId, flowId);
            
            const validation = {
                valid: true,
                errors: []
            };

            // Check if flow has screens
            if (!flowData.screens || flowData.screens.length === 0) {
                validation.valid = false;
                validation.errors.push('Flow must have at least one screen');
            }

            // Check for required fields in screens
            flowData.screens?.forEach((screen, index) => {
                if (!screen.id) {
                    validation.valid = false;
                    validation.errors.push(`Screen ${index} missing ID`);
                }
                if (!screen.title) {
                    validation.valid = false;
                    validation.errors.push(`Screen ${index} missing title`);
                }
            });

            return validation;
        } catch (error) {
            return {
                valid: false,
                errors: [`Content validation error: ${error.message}`]
            };
        }
    }

    async validateFlowRouting(appId, flowId) {
        // This would validate the flow's routing logic
        try {
            const flowData = await this.getFlowData(appId, flowId);
            
            const validation = {
                valid: true,
                errors: []
            };

            const screenIds = flowData.screens?.map(s => s.id) || [];
            
            // Validate routing references
            flowData.routing?.forEach((route, index) => {
                if (!screenIds.includes(route.source)) {
                    validation.valid = false;
                    validation.errors.push(`Route ${index}: source screen "${route.source}" not found`);
                }
                if (!screenIds.includes(route.target)) {
                    validation.valid = false;
                    validation.errors.push(`Route ${index}: target screen "${route.target}" not found`);
                }
            });

            return validation;
        } catch (error) {
            return {
                valid: false,
                errors: [`Routing validation error: ${error.message}`]
            };
        }
    }

    async getFlowData(appId, flowId) {
        // This would get the flow's JSON data
        // For now, return a placeholder structure
        return {
            screens: [
                { id: 'screen1', title: 'Welcome' }
            ],
            routing: []
        };
    }

    async createPublicationBackup(appId, flowId) {
        try {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const backupId = `backup-${flowId}-${timestamp}`;
            
            // Get current flow data
            const flowData = await this.getFlowData(appId, flowId);
            
            // Store backup (in production, this would be saved to storage)
            console.log(`Creating backup ${backupId} for flow ${flowId}`);
            
            return backupId;
        } catch (error) {
            throw new Error(`Failed to create backup: ${error.message}`);
        }
    }

    async performPublication(appId, flowId) {
        try {
            const response = await axios.post(
                `${this.baseUrl}/partner/app/${appId}/flows/${flowId}/publish`,
                {},
                {
                    headers: {
                        'Authorization': this.partnerToken,
                        'Content-Type': 'application/json'
                    }
                }
            );

            return response.data;
        } catch (error) {
            throw new Error(`Publication failed: ${error.response?.data?.message || error.message}`);
        }
    }

    recordPublication(appId, flowId, result, status, error = null) {
        const key = `${appId}-${flowId}`;
        const history = this.publicationHistory.get(key) || [];
        
        const record = {
            timestamp: new Date().toISOString(),
            status,
            result,
            error
        };
        
        history.push(record);
        this.publicationHistory.set(key, history);
    }

    async sendPublicationNotification(appId, flowId, status, result) {
        // In production, this would send notifications via email, Slack, etc.
        const message = status === 'success' 
            ? `Flow ${flowId} published successfully`
            : `Flow ${flowId} publication failed`;
        
        console.log(`ðŸ“¢ NOTIFICATION: ${message}`);
        
        // Example webhook notification
        // await this.sendWebhookNotification({ appId, flowId, status, result });
    }

    async retryPublication(appId, flowId, originalOptions, attempt = 1) {
        const maxRetries = 3;
        const delay = Math.pow(2, attempt) * 1000;
        
        if (attempt > maxRetries) {
            throw new Error(`Publication failed after ${maxRetries} retries`);
        }
        
        console.log(`Retrying publication attempt ${attempt}/${maxRetries} in ${delay}ms`);
        await this.sleep(delay);
        
        try {
            return await this.publishFlow(appId, flowId, { ...originalOptions, retryOnFailure: false });
        } catch (error) {
            return await this.retryPublication(appId, flowId, originalOptions, attempt + 1);
        }
    }

    async batchPublishFlows(flows, options = {}) {
        const {
            batchSize = 5,
            delay = 2000,
            continueOnError = true
        } = options;

        const results = [];
        
        for (let i = 0; i < flows.length; i += batchSize) {
            const batch = flows.slice(i, i + batchSize);
            
            const batchPromises = batch.map(async ({ appId, flowId, options: flowOptions }) => {
                try {
                    const result = await this.publishFlow(appId, flowId, flowOptions);
                    return { appId, flowId, success: true, result };
                } catch (error) {
                    const errorResult = { appId, flowId, success: false, error: error.message };
                    
                    if (!continueOnError) {
                        throw error;
                    }
                    
                    return errorResult;
                }
            });

            const batchResults = await Promise.allSettled(batchPromises);
            
            batchResults.forEach((result, index) => {
                if (result.status === 'fulfilled') {
                    results.push(result.value);
                } else {
                    const { appId, flowId } = batch[index];
                    results.push({
                        appId,
                        flowId,
                        success: false,
                        error: result.reason.message
                    });
                }
            });

            // Add delay between batches
            if (i + batchSize < flows.length) {
                await this.sleep(delay);
            }
        }

        return {
            results,
            summary: {
                total: flows.length,
                successful: results.filter(r => r.success).length,
                failed: results.filter(r => !r.success).length
            }
        };
    }

    async schedulePublication(appId, flowId, publishTime, options = {}) {
        const now = new Date();
        const targetTime = new Date(publishTime);
        
        if (targetTime <= now) {
            throw new Error('Publish time must be in the future');
        }
        
        const delay = targetTime - now;
        const scheduleId = `sched-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        
        // Store pending publication
        this.pendingPublications.set(scheduleId, {
            appId,
            flowId,
            publishTime: targetTime.toISOString(),
            options,
            status: 'scheduled'
        });
        
        // Schedule the publication
        setTimeout(async () => {
            try {
                const pending = this.pendingPublications.get(scheduleId);
                pending.status = 'executing';
                
                const result = await this.publishFlow(appId, flowId, options);
                
                pending.status = 'completed';
                pending.result = result;
                
                console.log(`âœ… Scheduled publication completed for flow ${flowId}`);
            } catch (error) {
                const pending = this.pendingPublications.get(scheduleId);
                pending.status = 'failed';
                pending.error = error.message;
                
                console.error(`âŒ Scheduled publication failed for flow ${flowId}:`, error.message);
            }
        }, delay);
        
        return {
            scheduleId,
            flowId,
            scheduledFor: targetTime.toISOString(),
            delay: `${Math.floor(delay / 1000)} seconds`
        };
    }

    getPublicationHistory(appId, flowId) {
        const key = `${appId}-${flowId}`;
        return this.publicationHistory.get(key) || [];
    }

    getPendingPublications() {
        const pending = [];
        for (const [scheduleId, publication] of this.pendingPublications) {
            pending.push({ scheduleId, ...publication });
        }
        return pending;
    }

    cancelScheduledPublication(scheduleId) {
        const publication = this.pendingPublications.get(scheduleId);
        if (publication && publication.status === 'scheduled') {
            publication.status = 'cancelled';
            return true;
        }
        return false;
    }

    generatePublicationReport(appId, flowId = null) {
        const report = {
            timestamp: new Date().toISOString(),
            appId,
            flowId
        };

        if (flowId) {
            // Single flow report
            const history = this.getPublicationHistory(appId, flowId);
            report.publications = history;
            report.summary = {
                totalAttempts: history.length,
                successful: history.filter(p => p.status === 'success').length,
                failed: history.filter(p => p.status === 'failed').length,
                lastPublication: history.length > 0 ? history[history.length - 1] : null
            };
        } else {
            // App-wide report
            const allPublications = [];
            for (const [key, history] of this.publicationHistory) {
                if (key.startsWith(appId + '-')) {
                    const flowId = key.split('-')[1];
                    allPublications.push({ flowId, history });
                }
            }
            
            report.flows = allPublications;
            report.summary = {
                totalFlows: allPublications.length,
                totalAttempts: allPublications.reduce((sum, flow) => sum + flow.history.length, 0),
                successful: allPublications.reduce((sum, flow) => 
                    sum + flow.history.filter(p => p.status === 'success').length, 0),
                failed: allPublications.reduce((sum, flow) => 
                    sum + flow.history.filter(p => p.status === 'failed').length, 0)
            };
        }

        return report;
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// Usage
const publicationManager = new FlowPublicationManager('https://partner.gupshup.io', 'your-partner-token');

// Publish with comprehensive options
publicationManager.publishFlow('your-app-id', 'your-flow-id', {
    validateBefore: true,
    createBackup: true,
    notifyOnSuccess: true,
    retryOnFailure: true
})
    .then(result => {
        console.log('Flow published with full validation:', result);
    })
    .catch(error => {
        console.error('Publication error:', error.message);
    });

// Batch publish flows
const flowsToPublish = [
    { appId: 'app1', flowId: 'flow1', options: { validateBefore: true } },
    { appId: 'app1', flowId: 'flow2', options: { createBackup: true } }
];

publicationManager.batchPublishFlows(flowsToPublish, {
    batchSize: 2,
    delay: 3000,
    continueOnError: true
})
    .then(result => {
        console.log('Batch publication results:', result);
    })
    .catch(error => {
        console.error('Batch publication error:', error);
    });

// Schedule publication
const publishTime = new Date(Date.now() + 60000); // 1 minute from now
publicationManager.schedulePublication('your-app-id', 'your-flow-id', publishTime, {
    validateBefore: true,
    notifyOnSuccess: true
})
    .then(schedule => {
        console.log('Publication scheduled:', schedule);
    })
    .catch(error => {
        console.error('Scheduling error:', error);
    });
```

### Flow Publication Pipeline
```javascript
class FlowPublicationPipeline {
    constructor(publicationManager) {
        this.publicationManager = publicationManager;
        this.pipeline = [];
        this.hooks = {
            preValidation: [],
            postValidation: [],
            prePublication: [],
            postPublication: []
        };
    }

    addHook(event, callback) {
        if (this.hooks[event]) {
            this.hooks[event].push(callback);
        }
    }

    async executeHooks(event, context) {
        for (const hook of this.hooks[event]) {
            await hook(context);
        }
    }

    async publishWithPipeline(appId, flowId, options = {}) {
        const context = {
            appId,
            flowId,
            options,
            startTime: new Date(),
            steps: []
        };

        try {
            // Pre-validation hooks
            await this.executeHooks('preValidation', context);
            context.steps.push({ step: 'preValidation', status: 'completed', timestamp: new Date() });

            // Validation
            const validation = await this.publicationManager.validateFlowForPublication(appId, flowId);
            context.validation = validation;
            context.steps.push({ step: 'validation', status: 'completed', timestamp: new Date() });

            // Post-validation hooks
            await this.executeHooks('postValidation', context);
            context.steps.push({ step: 'postValidation', status: 'completed', timestamp: new Date() });

            // Pre-publication hooks
            await this.executeHooks('prePublication', context);
            context.steps.push({ step: 'prePublication', status: 'completed', timestamp: new Date() });

            // Publication
            const result = await this.publicationManager.performPublication(appId, flowId);
            context.result = result;
            context.steps.push({ step: 'publication', status: 'completed', timestamp: new Date() });

            // Post-publication hooks
            await this.executeHooks('postPublication', context);
            context.steps.push({ step: 'postPublication', status: 'completed', timestamp: new Date() });

            context.endTime = new Date();
            context.duration = context.endTime - context.startTime;
            context.status = 'success';

            return context;
        } catch (error) {
            context.endTime = new Date();
            context.duration = context.endTime - context.startTime;
            context.status = 'failed';
            context.error = error.message;
            
            throw error;
        }
    }

    async createPublicationPlan(flows) {
        const plan = {
            id: `plan-${Date.now()}`,
            created: new Date().toISOString(),
            flows: flows.map((flow, index) => ({
                ...flow,
                order: index + 1,
                status: 'pending'
            })),
            status: 'created'
        };

        return plan;
    }

    async executePlan(plan, options = {}) {
        const { 
            parallel = false, 
            stopOnError = false,
            delay = 1000 
        } = options;

        plan.status = 'executing';
        plan.startTime = new Date().toISOString();

        const results = [];

        if (parallel) {
            // Execute all flows in parallel
            const promises = plan.flows.map(async (flow) => {
                try {
                    flow.status = 'executing';
                    const result = await this.publishWithPipeline(flow.appId, flow.flowId, flow.options);
                    flow.status = 'completed';
                    flow.result = result;
                    return { flow, success: true };
                } catch (error) {
                    flow.status = 'failed';
                    flow.error = error.message;
                    return { flow, success: false, error };
                }
            });

            const outcomes = await Promise.allSettled(promises);
            results.push(...outcomes.map(outcome => 
                outcome.status === 'fulfilled' ? outcome.value : outcome.reason
            ));
        } else {
            // Execute flows sequentially
            for (const flow of plan.flows) {
                try {
                    flow.status = 'executing';
                    const result = await this.publishWithPipeline(flow.appId, flow.flowId, flow.options);
                    flow.status = 'completed';
                    flow.result = result;
                    results.push({ flow, success: true });

                    // Add delay between publications
                    if (delay > 0) {
                        await this.sleep(delay);
                    }
                } catch (error) {
                    flow.status = 'failed';
                    flow.error = error.message;
                    results.push({ flow, success: false, error });

                    if (stopOnError) {
                        break;
                    }
                }
            }
        }

        plan.status = 'completed';
        plan.endTime = new Date().toISOString();
        plan.results = results;

        return plan;
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// Usage
const publicationManager = new FlowPublicationManager('https://partner.gupshup.io', 'your-partner-token');
const pipeline = new FlowPublicationPipeline(publicationManager);

// Add hooks
pipeline.addHook('preValidation', async (context) => {
    console.log(`Starting validation for flow ${context.flowId}`);
});

pipeline.addHook('postPublication', async (context) => {
    console.log(`Flow ${context.flowId} published successfully`);
    // Send notification, update database, etc.
});

// Create and execute publication plan
const flows = [
    { appId: 'app1', flowId: 'flow1', options: { validateBefore: true } },
    { appId: 'app1', flowId: 'flow2', options: { createBackup: true } }
];

pipeline.createPublicationPlan(flows)
    .then(plan => {
        console.log('Publication plan created:', plan);
        return pipeline.executePlan(plan, { parallel: false, delay: 2000 });
    })
    .then(result => {
        console.log('Plan execution completed:', result);
    })
    .catch(error => {
        console.error('Plan execution failed:', error);
    });
```

## Response Fields

| Field | Type | Description |
|-------|------|-------------|
| status | String | Response status ("success" or "error") |
| success | Boolean | Whether the operation was successful |
| message | String | Error message (only present in error responses) |

## Error Handling

```javascript
function handlePublishFlowError(error) {
    if (error.response) {
        const { status, data } = error.response;
        
        switch (status) {
            case 400:
                if (data.message.includes('not in DRAFT state')) {
                    console.error('Flow Publication Error: Flow is not in DRAFT state');
                    return 'NOT_IN_DRAFT_STATE';
                }
                console.error('Bad Request:', data.message);
                return 'BAD_REQUEST';
            case 401:
                console.error('Unauthorized: Invalid partner token');
                return 'UNAUTHORIZED';
            case 403:
                console.error('Forbidden: Insufficient permissions');
                return 'FORBIDDEN';
            case 404:
                console.error('Not Found: Flow not found');
                return 'NOT_FOUND';
            case 500:
                console.error('Server Error: Try again later');
                return 'SERVER_ERROR';
            default:
                console.error('Unknown error:', data);
                return 'UNKNOWN_ERROR';
        }
    } else if (error.request) {
        console.error('Network error: No response received');
        return 'NETWORK_ERROR';
    } else {
        console.error('Error:', error.message);
        return 'UNKNOWN_ERROR';
    }
}
```

## Best Practices

1. **Status Validation**: Always verify flow is in DRAFT status before publishing
2. **Pre-Publication Validation**: Validate flow content and structure
3. **Backup Creation**: Create backups before publishing important flows
4. **Error Handling**: Implement comprehensive error handling
5. **Retry Logic**: Add retry logic for transient failures
6. **Batch Processing**: Process multiple publications with appropriate delays
7. **Monitoring**: Monitor publication success rates and failures
8. **Notifications**: Implement notification systems for publication events
9. **Rollback Planning**: Have rollback strategies for failed publications
10. **Testing**: Test flows thoroughly before publishing

## Publication Prerequisites

### Flow Status Requirements
- Flow must be in **DRAFT** status
- Flow must have valid JSON structure
- Flow must pass all validation rules

### Content Requirements
- At least one screen must be defined
- All screens must have required fields (id, title)
- Routing must reference valid screen IDs
- No validation errors should exist

### Permission Requirements
- Valid Partner App Token
- Sufficient permissions for the app
- Access to the specific flow

## Common Use Cases

### 1. Simple Publication
```javascript
const result = await flowPublisher.publishFlow(appId, flowId);
```

### 2. Publication with Validation
```javascript
const result = await flowPublisher.publishFlowWithValidation(appId, flowId);
```

### 3. Batch Publication
```javascript
const flows = [
    { appId: 'app1', flowId: 'flow1' },
    { appId: 'app1', flowId: 'flow2' }
];
const results = await flowPublisher.publishMultipleFlows(flows);
```

### 4. Scheduled Publication
```javascript
const publishTime = new Date(Date.now() + 3600000); // 1 hour from now
const schedule = await flowPublisher.scheduleFlowPublication(appId, flowId, publishTime);
```

### 5. Publication with Pipeline
```javascript
const context = await pipeline.publishWithPipeline(appId, flowId, {
    validateBefore: true,
    createBackup: true,
    notifyOnSuccess: true
});
```

## Publication States

- **DRAFT**: Flow is ready for publication
- **PUBLISHING**: Publication is in progress
- **PUBLISHED**: Flow is live and active
- **FAILED**: Publication failed (flow remains in DRAFT)

## Important Notes

- **Draft Status Required**: Only flows in DRAFT status can be published
- **Irreversible Action**: Publication cannot be undone (flow must be deprecated then recreated)
- **Validation Required**: Flows must pass all validation checks before publishing
- **Live Immediately**: Published flows become live immediately
- **Meta Approval**: Some flows may require Meta approval before going live
- **Rate Limiting**: Be mindful of API rate limits for batch publications
- **Monitoring**: Monitor published flows for performance and issues
- **Backup Strategy**: Always have backup and rollback strategies
- **Testing**: Test flows thoroughly in DRAFT mode before publishing
- **Documentation**: Document all publications for audit and compliance purposes