# Gupshup Update Flow JSON API

## Overview
The Update Flow JSON API allows you to update the JSON configuration of a flow by uploading a new JSON file. This API enables you to modify the flow's structure, logic, and configuration programmatically by providing a complete JSON definition.

## Base URL
```
https://partner.gupshup.io/partner/app/{appId}/flows/{flowId}/assets
```

## Authentication
- **Method**: Bearer Token
- **Header**: `Authorization: {PARTNER_APP_TOKEN}`

## Endpoint

### Update Flow JSON
**PUT** `/partner/app/{appId}/flows/{flowId}/assets`

Updates the flow's JSON configuration by uploading a new JSON file.

#### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| Authorization | String | Yes | Access Token for the application |
| appId | String | Yes | App ID of the application |
| flowId | String | Yes | Flow ID generated by Meta |
| file | File | Yes | JSON file containing the flow configuration |

#### Content Type
- **multipart/form-data** (for file upload)

#### Sample cURL Request
```bash
curl --location --request PUT 'https://partner.gupshup.io/partner/app/{{APP_ID}}/flows/{{FLOW_ID}}/assets' \
--header 'Authorization: {{PARTNER_APP_TOKEN}}' \
--form 'file=@{{FILE_PATH}}'
```

**Real Example:**
```bash
curl --location --request PUT 'https://partner.gupshup.io/partner/app/YOUR_APP_ID/flows/YOUR_FLOW_ID/assets' \
--header 'Authorization: YOUR_PARTNER_APP_TOKEN' \
--form 'file=@/path/to/your/flow.json'
```

#### Sample Response
```json
{
    "status": "success",
    "success": true,
    "validation_errors": []
}
```

#### Status Codes

| Status | Response | Description |
|--------|----------|-------------|
| 200 | `{ "status": "success", "success": true, "validation_errors": [] }` | Successfully updated JSON |
| 400 | `{ "status": "error", "message": "Unable to upload Flow JSON Asset as media size is greater than permitted size" }` | For updating JSON over 10MB |
| 401 | `{ "status": "error", "message": "Unauthorized" }` | Invalid or missing authorization token |
| 404 | `{ "status": "error", "message": "Flow not found" }` | Flow ID not found |

## Node.js Examples

### Basic Update Flow JSON
```javascript
const fs = require('fs');
const FormData = require('form-data');
const fetch = require('node-fetch');

async function updateFlowJson(appId, flowId, partnerToken, jsonFilePath) {
    try {
        // Create form data
        const formData = new FormData();
        formData.append('file', fs.createReadStream(jsonFilePath));

        const response = await fetch(`https://partner.gupshup.io/partner/app/${appId}/flows/${flowId}/assets`, {
            method: 'PUT',
            headers: {
                'Authorization': partnerToken,
                ...formData.getHeaders()
            },
            body: formData
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`HTTP error! status: ${response.status}, message: ${errorData.message}`);
        }

        return await response.json();
    } catch (error) {
        throw new Error(`Failed to update flow JSON: ${error.message}`);
    }
}

// Usage
updateFlowJson('your-app-id', 'your-flow-id', 'your-partner-token', './flow.json')
    .then(response => {
        console.log('Flow JSON updated successfully:', response);
    })
    .catch(error => {
        console.error('Error updating flow JSON:', error);
    });
```

### Advanced Flow JSON Manager
```javascript
const fs = require('fs').promises;
const FormData = require('form-data');
const axios = require('axios');
const path = require('path');

class FlowJsonManager {
    constructor(baseUrl, partnerToken) {
        this.baseUrl = baseUrl || 'https://partner.gupshup.io';
        this.partnerToken = partnerToken;
        this.maxFileSize = 10 * 1024 * 1024; // 10MB
    }

    async updateFlowJson(appId, flowId, jsonFilePath) {
        try {
            // Validate file
            await this.validateJsonFile(jsonFilePath);

            // Create form data
            const formData = new FormData();
            formData.append('file', await fs.readFile(jsonFilePath), {
                filename: path.basename(jsonFilePath),
                contentType: 'application/json'
            });

            const response = await axios.put(
                `${this.baseUrl}/partner/app/${appId}/flows/${flowId}/assets`,
                formData,
                {
                    headers: {
                        'Authorization': this.partnerToken,
                        ...formData.getHeaders()
                    }
                }
            );

            return response.data;
        } catch (error) {
            throw new Error(`Failed to update flow JSON: ${error.message}`);
        }
    }

    async updateFlowJsonFromObject(appId, flowId, jsonObject) {
        try {
            // Validate JSON object
            this.validateJsonObject(jsonObject);

            // Create temporary file
            const tempFilePath = `/tmp/flow-${Date.now()}.json`;
            await fs.writeFile(tempFilePath, JSON.stringify(jsonObject, null, 2));

            // Update flow JSON
            const result = await this.updateFlowJson(appId, flowId, tempFilePath);

            // Clean up temporary file
            await fs.unlink(tempFilePath);

            return result;
        } catch (error) {
            throw new Error(`Failed to update flow JSON from object: ${error.message}`);
        }
    }

    async validateJsonFile(filePath) {
        try {
            // Check if file exists
            await fs.access(filePath);

            // Check file size
            const stats = await fs.stat(filePath);
            if (stats.size > this.maxFileSize) {
                throw new Error(`File size ${stats.size} bytes exceeds maximum allowed size of ${this.maxFileSize} bytes`);
            }

            // Check if it's valid JSON
            const content = await fs.readFile(filePath, 'utf8');
            JSON.parse(content);

            return true;
        } catch (error) {
            throw new Error(`Invalid JSON file: ${error.message}`);
        }
    }

    validateJsonObject(jsonObject) {
        if (!jsonObject || typeof jsonObject !== 'object') {
            throw new Error('Invalid JSON object provided');
        }

        // Basic flow JSON structure validation
        if (!jsonObject.version) {
            throw new Error('Flow JSON must have a version property');
        }

        if (!jsonObject.screens || !Array.isArray(jsonObject.screens)) {
            throw new Error('Flow JSON must have a screens array');
        }

        return true;
    }

    async updateFlowJsonWithValidation(appId, flowId, jsonFilePath) {
        try {
            // Validate file
            await this.validateJsonFile(jsonFilePath);

            // Read and parse JSON
            const content = await fs.readFile(jsonFilePath, 'utf8');
            const jsonObject = JSON.parse(content);

            // Validate flow structure
            this.validateFlowStructure(jsonObject);

            // Update flow JSON
            const result = await this.updateFlowJson(appId, flowId, jsonFilePath);

            return result;
        } catch (error) {
            throw new Error(`Validation failed: ${error.message}`);
        }
    }

    validateFlowStructure(jsonObject) {
        // Validate version
        if (!jsonObject.version || typeof jsonObject.version !== 'string') {
            throw new Error('Flow must have a valid version string');
        }

        // Validate screens
        if (!jsonObject.screens || !Array.isArray(jsonObject.screens)) {
            throw new Error('Flow must have a screens array');
        }

        if (jsonObject.screens.length === 0) {
            throw new Error('Flow must have at least one screen');
        }

        // Validate each screen
        jsonObject.screens.forEach((screen, index) => {
            if (!screen.id) {
                throw new Error(`Screen at index ${index} must have an id`);
            }
            if (!screen.title) {
                throw new Error(`Screen at index ${index} must have a title`);
            }
        });

        // Validate routing
        if (jsonObject.routing && !Array.isArray(jsonObject.routing)) {
            throw new Error('Routing must be an array');
        }

        return true;
    }

    async backupFlowJson(appId, flowId, backupPath) {
        try {
            // Get current flow JSON (would need a get flow JSON API)
            const currentJson = await this.getCurrentFlowJson(appId, flowId);
            
            // Create backup file
            const backupFilePath = path.join(backupPath, `flow-${flowId}-${Date.now()}.json`);
            await fs.writeFile(backupFilePath, JSON.stringify(currentJson, null, 2));

            return backupFilePath;
        } catch (error) {
            throw new Error(`Failed to backup flow JSON: ${error.message}`);
        }
    }

    async getCurrentFlowJson(appId, flowId) {
        // This would use the Get Flow JSON API
        // For now, return a placeholder
        return {
            version: "1.0",
            screens: [],
            routing: []
        };
    }

    async updateFlowJsonWithBackup(appId, flowId, jsonFilePath, backupPath) {
        try {
            // Create backup
            const backupFilePath = await this.backupFlowJson(appId, flowId, backupPath);
            console.log(`Backup created: ${backupFilePath}`);

            // Update flow JSON
            const result = await this.updateFlowJsonWithValidation(appId, flowId, jsonFilePath);

            return {
                result,
                backupPath: backupFilePath
            };
        } catch (error) {
            throw new Error(`Failed to update flow JSON with backup: ${error.message}`);
        }
    }

    async batchUpdateFlowJson(updates) {
        const results = [];

        for (const update of updates) {
            try {
                const result = await this.updateFlowJsonWithValidation(
                    update.appId,
                    update.flowId,
                    update.jsonFilePath
                );

                results.push({
                    appId: update.appId,
                    flowId: update.flowId,
                    success: true,
                    result
                });
            } catch (error) {
                results.push({
                    appId: update.appId,
                    flowId: update.flowId,
                    success: false,
                    error: error.message
                });
            }
        }

        return results;
    }
}

// Usage
const flowJsonManager = new FlowJsonManager('https://partner.gupshup.io', 'your-partner-token');

// Update flow JSON with validation
flowJsonManager.updateFlowJsonWithValidation('your-app-id', 'your-flow-id', './flow.json')
    .then(result => {
        console.log('Flow JSON updated with validation:', result);
    })
    .catch(error => {
        console.error('Error:', error.message);
    });

// Update flow JSON from object
const flowObject = {
    version: "1.0",
    screens: [
        {
            id: "screen1",
            title: "Welcome Screen",
            body: "Welcome to our service!"
        }
    ],
    routing: []
};

flowJsonManager.updateFlowJsonFromObject('your-app-id', 'your-flow-id', flowObject)
    .then(result => {
        console.log('Flow JSON updated from object:', result);
    })
    .catch(error => {
        console.error('Error:', error.message);
    });
```

### Flow JSON Builder and Validator
```javascript
class FlowJsonBuilder {
    constructor() {
        this.flow = {
            version: "2.1",
            screens: [],
            routing: []
        };
    }

    setVersion(version) {
        this.flow.version = version;
        return this;
    }

    addScreen(screen) {
        if (!screen.id || !screen.title) {
            throw new Error('Screen must have id and title');
        }

        this.flow.screens.push(screen);
        return this;
    }

    addTextScreen(id, title, body) {
        return this.addScreen({
            id,
            title,
            body,
            type: "text"
        });
    }

    addInputScreen(id, title, body, inputType = "text") {
        return this.addScreen({
            id,
            title,
            body,
            type: "input",
            input_type: inputType
        });
    }

    addButtonScreen(id, title, body, buttons) {
        return this.addScreen({
            id,
            title,
            body,
            type: "button",
            buttons
        });
    }

    addRouting(sourceScreen, targetScreen, condition = null) {
        const routing = {
            source: sourceScreen,
            target: targetScreen
        };

        if (condition) {
            routing.condition = condition;
        }

        this.flow.routing.push(routing);
        return this;
    }

    build() {
        this.validate();
        return { ...this.flow };
    }

    validate() {
        if (this.flow.screens.length === 0) {
            throw new Error('Flow must have at least one screen');
        }

        // Validate screen IDs are unique
        const screenIds = this.flow.screens.map(screen => screen.id);
        const duplicates = screenIds.filter((id, index) => screenIds.indexOf(id) !== index);
        if (duplicates.length > 0) {
            throw new Error(`Duplicate screen IDs found: ${duplicates.join(', ')}`);
        }

        // Validate routing references
        this.flow.routing.forEach(route => {
            if (!screenIds.includes(route.source)) {
                throw new Error(`Routing source screen "${route.source}" not found`);
            }
            if (!screenIds.includes(route.target)) {
                throw new Error(`Routing target screen "${route.target}" not found`);
            }
        });

        return true;
    }

    toJson() {
        return JSON.stringify(this.build(), null, 2);
    }

    saveToFile(filePath) {
        const fs = require('fs').promises;
        return fs.writeFile(filePath, this.toJson());
    }
}

// Usage
const builder = new FlowJsonBuilder();

const flowJson = builder
    .setVersion("2.1")
    .addTextScreen("welcome", "Welcome", "Welcome to our service!")
    .addInputScreen("name", "Your Name", "What's your name?", "text")
    .addButtonScreen("menu", "Main Menu", "What would you like to do?", [
        { id: "support", title: "Support" },
        { id: "info", title: "Information" }
    ])
    .addRouting("welcome", "name")
    .addRouting("name", "menu")
    .build();

console.log('Built flow JSON:', flowJson);
```

### Advanced Flow JSON Operations
```javascript
class AdvancedFlowJsonManager extends FlowJsonManager {
    constructor(baseUrl, partnerToken) {
        super(baseUrl, partnerToken);
        this.templates = new Map();
        this.validationRules = new Map();
    }

    async updateFlowJsonWithTemplate(appId, flowId, templateName, variables = {}) {
        try {
            const template = this.templates.get(templateName);
            if (!template) {
                throw new Error(`Template "${templateName}" not found`);
            }

            // Apply variables to template
            const processedTemplate = this.processTemplate(template, variables);

            // Update flow JSON
            return await this.updateFlowJsonFromObject(appId, flowId, processedTemplate);
        } catch (error) {
            throw new Error(`Failed to update flow JSON with template: ${error.message}`);
        }
    }

    processTemplate(template, variables) {
        let templateStr = JSON.stringify(template);
        
        // Replace variables
        for (const [key, value] of Object.entries(variables)) {
            const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
            templateStr = templateStr.replace(regex, value);
        }

        return JSON.parse(templateStr);
    }

    addTemplate(name, template) {
        this.templates.set(name, template);
    }

    addValidationRule(name, rule) {
        this.validationRules.set(name, rule);
    }

    async validateFlowJsonWithCustomRules(jsonObject) {
        const errors = [];

        for (const [name, rule] of this.validationRules) {
            try {
                const result = rule(jsonObject);
                if (result !== true) {
                    errors.push(`${name}: ${result}`);
                }
            } catch (error) {
                errors.push(`${name}: ${error.message}`);
            }
        }

        if (errors.length > 0) {
            throw new Error(`Validation failed: ${errors.join(', ')}`);
        }

        return true;
    }

    async updateFlowJsonWithDiff(appId, flowId, diffObject) {
        try {
            // Get current flow JSON
            const currentJson = await this.getCurrentFlowJson(appId, flowId);
            
            // Apply diff
            const updatedJson = this.applyDiff(currentJson, diffObject);
            
            // Update flow JSON
            return await this.updateFlowJsonFromObject(appId, flowId, updatedJson);
        } catch (error) {
            throw new Error(`Failed to update flow JSON with diff: ${error.message}`);
        }
    }

    applyDiff(original, diff) {
        const result = JSON.parse(JSON.stringify(original));

        for (const [path, value] of Object.entries(diff)) {
            this.setNestedProperty(result, path, value);
        }

        return result;
    }

    setNestedProperty(obj, path, value) {
        const keys = path.split('.');
        let current = obj;

        for (let i = 0; i < keys.length - 1; i++) {
            const key = keys[i];
            if (!(key in current)) {
                current[key] = {};
            }
            current = current[key];
        }

        current[keys[keys.length - 1]] = value;
    }

    async versionFlowJson(appId, flowId, jsonFilePath, versionInfo) {
        try {
            // Read and parse JSON
            const content = await fs.readFile(jsonFilePath, 'utf8');
            const jsonObject = JSON.parse(content);

            // Add version metadata
            jsonObject.metadata = {
                ...jsonObject.metadata,
                version: versionInfo.version,
                author: versionInfo.author,
                changelog: versionInfo.changelog,
                timestamp: new Date().toISOString()
            };

            // Update flow JSON
            return await this.updateFlowJsonFromObject(appId, flowId, jsonObject);
        } catch (error) {
            throw new Error(`Failed to version flow JSON: ${error.message}`);
        }
    }

    async compareFlowJsons(json1, json2) {
        const differences = [];

        // Compare screens
        const screens1 = json1.screens || [];
        const screens2 = json2.screens || [];

        const screenIds1 = screens1.map(s => s.id);
        const screenIds2 = screens2.map(s => s.id);

        // Added screens
        const addedScreens = screenIds2.filter(id => !screenIds1.includes(id));
        addedScreens.forEach(id => {
            differences.push({
                type: 'added',
                category: 'screen',
                id,
                description: `Screen "${id}" was added`
            });
        });

        // Removed screens
        const removedScreens = screenIds1.filter(id => !screenIds2.includes(id));
        removedScreens.forEach(id => {
            differences.push({
                type: 'removed',
                category: 'screen',
                id,
                description: `Screen "${id}" was removed`
            });
        });

        // Modified screens
        const commonScreens = screenIds1.filter(id => screenIds2.includes(id));
        commonScreens.forEach(id => {
            const screen1 = screens1.find(s => s.id === id);
            const screen2 = screens2.find(s => s.id === id);
            
            if (JSON.stringify(screen1) !== JSON.stringify(screen2)) {
                differences.push({
                    type: 'modified',
                    category: 'screen',
                    id,
                    description: `Screen "${id}" was modified`
                });
            }
        });

        return differences;
    }

    async generateFlowJsonReport(appId, flowId, jsonFilePath) {
        try {
            const content = await fs.readFile(jsonFilePath, 'utf8');
            const jsonObject = JSON.parse(content);

            const report = {
                timestamp: new Date().toISOString(),
                appId,
                flowId,
                analysis: {
                    version: jsonObject.version,
                    screenCount: jsonObject.screens?.length || 0,
                    routingCount: jsonObject.routing?.length || 0,
                    complexity: this.calculateComplexity(jsonObject),
                    screens: this.analyzeScreens(jsonObject.screens || []),
                    routing: this.analyzeRouting(jsonObject.routing || [])
                },
                validation: {
                    isValid: false,
                    errors: []
                }
            };

            try {
                this.validateFlowStructure(jsonObject);
                report.validation.isValid = true;
            } catch (error) {
                report.validation.errors.push(error.message);
            }

            return report;
        } catch (error) {
            throw new Error(`Failed to generate flow JSON report: ${error.message}`);
        }
    }

    calculateComplexity(jsonObject) {
        const screens = jsonObject.screens || [];
        const routing = jsonObject.routing || [];

        let complexity = 0;
        
        // Base complexity from screens
        complexity += screens.length;

        // Add complexity for routing
        complexity += routing.length * 2;

        // Add complexity for different screen types
        screens.forEach(screen => {
            if (screen.type === 'button') {
                complexity += (screen.buttons?.length || 0);
            } else if (screen.type === 'input') {
                complexity += 2;
            }
        });

        return complexity;
    }

    analyzeScreens(screens) {
        const analysis = {
            byType: {},
            withButtons: 0,
            withInputs: 0,
            averageButtonCount: 0
        };

        let totalButtons = 0;
        let screenWithButtons = 0;

        screens.forEach(screen => {
            // Count by type
            analysis.byType[screen.type || 'unknown'] = (analysis.byType[screen.type || 'unknown'] || 0) + 1;

            // Count buttons
            if (screen.buttons && screen.buttons.length > 0) {
                analysis.withButtons++;
                screenWithButtons++;
                totalButtons += screen.buttons.length;
            }

            // Count inputs
            if (screen.type === 'input') {
                analysis.withInputs++;
            }
        });

        analysis.averageButtonCount = screenWithButtons > 0 ? (totalButtons / screenWithButtons).toFixed(2) : 0;

        return analysis;
    }

    analyzeRouting(routing) {
        const analysis = {
            total: routing.length,
            withConditions: 0,
            sources: new Set(),
            targets: new Set()
        };

        routing.forEach(route => {
            if (route.condition) {
                analysis.withConditions++;
            }
            analysis.sources.add(route.source);
            analysis.targets.add(route.target);
        });

        analysis.sources = analysis.sources.size;
        analysis.targets = analysis.targets.size;

        return analysis;
    }
}

// Usage
const advancedManager = new AdvancedFlowJsonManager('https://partner.gupshup.io', 'your-partner-token');

// Add templates
advancedManager.addTemplate('welcome-flow', {
    version: "2.1",
    screens: [
        {
            id: "welcome",
            title: "{{title}}",
            body: "{{message}}",
            type: "text"
        }
    ],
    routing: []
});

// Add validation rules
advancedManager.addValidationRule('screen-limit', (json) => {
    const screenCount = json.screens?.length || 0;
    return screenCount <= 20 || `Too many screens: ${screenCount} (max 20)`;
});

// Update with template
advancedManager.updateFlowJsonWithTemplate('your-app-id', 'your-flow-id', 'welcome-flow', {
    title: 'Welcome to Our Service',
    message: 'We are glad to have you here!'
})
    .then(result => {
        console.log('Flow updated with template:', result);
    })
    .catch(error => {
        console.error('Error:', error.message);
    });

// Generate report
advancedManager.generateFlowJsonReport('your-app-id', 'your-flow-id', './flow.json')
    .then(report => {
        console.log('Flow JSON Report:', JSON.stringify(report, null, 2));
    })
    .catch(error => {
        console.error('Error generating report:', error);
    });
```

### Flow JSON Monitoring and Versioning
```javascript
class FlowJsonVersionManager {
    constructor(flowJsonManager) {
        this.flowJsonManager = flowJsonManager;
        this.versions = new Map();
        this.deployments = new Map();
    }

    async updateFlowJsonWithVersioning(appId, flowId, jsonFilePath, versionInfo) {
        try {
            // Create version entry
            const versionId = this.generateVersionId();
            const version = {
                id: versionId,
                appId,
                flowId,
                version: versionInfo.version,
                author: versionInfo.author,
                changelog: versionInfo.changelog,
                timestamp: new Date().toISOString(),
                filePath: jsonFilePath
            };

            // Store version
            this.versions.set(versionId, version);

            // Update flow JSON
            const result = await this.flowJsonManager.versionFlowJson(appId, flowId, jsonFilePath, versionInfo);

            // Record deployment
            this.deployments.set(`${appId}-${flowId}`, {
                versionId,
                deployedAt: new Date().toISOString(),
                result
            });

            return {
                versionId,
                result,
                version
            };
        } catch (error) {
            throw new Error(`Failed to update flow JSON with versioning: ${error.message}`);
        }
    }

    generateVersionId() {
        return `v${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }

    async rollbackFlowJson(appId, flowId, targetVersionId) {
        try {
            const version = this.versions.get(targetVersionId);
            if (!version) {
                throw new Error(`Version ${targetVersionId} not found`);
            }

            if (version.appId !== appId || version.flowId !== flowId) {
                throw new Error('Version does not belong to this flow');
            }

            // Update flow JSON with the target version
            const result = await this.flowJsonManager.updateFlowJsonWithValidation(
                appId, 
                flowId, 
                version.filePath
            );

            // Record rollback
            this.deployments.set(`${appId}-${flowId}`, {
                versionId: targetVersionId,
                deployedAt: new Date().toISOString(),
                result,
                isRollback: true
            });

            return {
                rolledBackTo: targetVersionId,
                result,
                version
            };
        } catch (error) {
            throw new Error(`Failed to rollback flow JSON: ${error.message}`);
        }
    }

    getVersionHistory(appId, flowId) {
        const history = [];
        
        for (const [versionId, version] of this.versions) {
            if (version.appId === appId && version.flowId === flowId) {
                history.push(version);
            }
        }

        return history.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    }

    getCurrentVersion(appId, flowId) {
        const deployment = this.deployments.get(`${appId}-${flowId}`);
        if (!deployment) {
            return null;
        }

        return this.versions.get(deployment.versionId);
    }

    async compareVersions(versionId1, versionId2) {
        try {
            const version1 = this.versions.get(versionId1);
            const version2 = this.versions.get(versionId2);

            if (!version1 || !version2) {
                throw new Error('One or both versions not found');
            }

            // Read JSON files
            const fs = require('fs').promises;
            const json1 = JSON.parse(await fs.readFile(version1.filePath, 'utf8'));
            const json2 = JSON.parse(await fs.readFile(version2.filePath, 'utf8'));

            // Compare JSONs
            const differences = await this.flowJsonManager.compareFlowJsons(json1, json2);

            return {
                version1,
                version2,
                differences,
                summary: {
                    totalChanges: differences.length,
                    added: differences.filter(d => d.type === 'added').length,
                    removed: differences.filter(d => d.type === 'removed').length,
                    modified: differences.filter(d => d.type === 'modified').length
                }
            };
        } catch (error) {
            throw new Error(`Failed to compare versions: ${error.message}`);
        }
    }

    async generateVersionReport(appId, flowId) {
        const history = this.getVersionHistory(appId, flowId);
        const currentVersion = this.getCurrentVersion(appId, flowId);

        return {
            appId,
            flowId,
            currentVersion,
            totalVersions: history.length,
            versions: history,
            deployment: this.deployments.get(`${appId}-${flowId}`),
            lastUpdated: history.length > 0 ? history[0].timestamp : null
        };
    }

    exportVersionHistory(appId, flowId, format = 'json') {
        const report = this.generateVersionReport(appId, flowId);
        
        if (format === 'csv') {
            const headers = ['Version ID', 'Version', 'Author', 'Timestamp', 'Changelog'];
            const csvRows = [headers.join(',')];
            
            report.versions.forEach(version => {
                const row = [
                    version.id,
                    version.version,
                    version.author,
                    version.timestamp,
                    `"${version.changelog.replace(/"/g, '""')}"`
                ];
                csvRows.push(row.join(','));
            });
            
            return csvRows.join('\n');
        }

        return report;
    }
}

// Usage
const flowJsonManager = new AdvancedFlowJsonManager('https://partner.gupshup.io', 'your-partner-token');
const versionManager = new FlowJsonVersionManager(flowJsonManager);

// Update with versioning
versionManager.updateFlowJsonWithVersioning('your-app-id', 'your-flow-id', './flow.json', {
    version: 'v1.2.0',
    author: 'John Doe',
    changelog: 'Added new welcome screen and improved routing'
})
    .then(result => {
        console.log('Flow updated with versioning:', result);
    })
    .catch(error => {
        console.error('Error:', error.message);
    });

// Get version history
const history = versionManager.getVersionHistory('your-app-id', 'your-flow-id');
console.log('Version History:', history);

// Compare versions
if (history.length >= 2) {
    versionManager.compareVersions(history[0].id, history[1].id)
        .then(comparison => {
            console.log('Version Comparison:', comparison);
        })
        .catch(error => {
            console.error('Error comparing versions:', error);
        });
}
```

## Response Fields

| Field | Type | Description |
|-------|------|-------------|
| status | String | Response status ("success" or "error") |
| success | Boolean | Whether the operation was successful |
| validation_errors | Array | List of validation errors (if any) |
| message | String | Error message (only present in error responses) |

## File Size Limits

- **Maximum file size**: 10MB
- **Format**: JSON files only
- **Encoding**: UTF-8 recommended

## Error Handling

```javascript
function handleFlowJsonUpdateError(error) {
    if (error.response) {
        const { status, data } = error.response;
        
        switch (status) {
            case 400:
                if (data.message.includes('media size is greater than permitted size')) {
                    console.error('File too large: JSON file must be under 10MB');
                    return 'FILE_TOO_LARGE';
                }
                console.error('Bad Request:', data.message);
                return 'BAD_REQUEST';
            case 401:
                console.error('Unauthorized: Invalid partner token');
                return 'UNAUTHORIZED';
            case 403:
                console.error('Forbidden: Insufficient permissions');
                return 'FORBIDDEN';
            case 404:
                console.error('Not Found: Flow not found');
                return 'NOT_FOUND';
            case 500:
                console.error('Server Error: Try again later');
                return 'SERVER_ERROR';
            default:
                console.error('Unknown error:', data);
                return 'UNKNOWN_ERROR';
        }
    } else if (error.request) {
        console.error('Network error: No response received');
        return 'NETWORK_ERROR';
    } else {
        console.error('Error:', error.message);
        return 'UNKNOWN_ERROR';
    }
}
```

## Best Practices

1. **File Validation**: Always validate JSON files before uploading
2. **Size Limits**: Keep JSON files under 10MB
3. **Backup**: Create backups before updating flow JSON
4. **Validation**: Validate flow structure and syntax
5. **Version Control**: Implement version control for flow JSON files
6. **Error Handling**: Implement comprehensive error handling
7. **Testing**: Test flow JSON in development environment first
8. **Documentation**: Document flow JSON structure and changes
9. **Monitoring**: Monitor flow JSON updates and performance
10. **Rollback**: Implement rollback capabilities for failed updates

## Flow JSON Structure

### Basic Structure
```json
{
    "version": "2.1",
    "screens": [
        {
            "id": "screen1",
            "title": "Screen Title",
            "body": "Screen content",
            "type": "text"
        }
    ],
    "routing": [
        {
            "source": "screen1",
            "target": "screen2"
        }
    ]
}
```

### Screen Types
- **text**: Simple text display
- **input**: User input screen
- **button**: Button selection screen
- **media**: Media display screen

### Routing Conditions
```json
{
    "source": "screen1",
    "target": "screen2",
    "condition": {
        "type": "user_input",
        "value": "yes"
    }
}
```

## Common Use Cases

### 1. Update Flow Structure
```javascript
const flowJson = {
    version: "2.1",
    screens: [
        {
            id: "welcome",
            title: "Welcome",
            body: "Welcome to our service!",
            type: "text"
        }
    ],
    routing: []
};

flowJsonManager.updateFlowJsonFromObject(appId, flowId, flowJson);
```

### 2. Add New Screen
```javascript
// Read existing flow, add screen, update
const existingFlow = await flowJsonManager.getCurrentFlowJson(appId, flowId);
existingFlow.screens.push({
    id: "new-screen",
    title: "New Screen",
    body: "This is a new screen",
    type: "text"
});
await flowJsonManager.updateFlowJsonFromObject(appId, flowId, existingFlow);
```

### 3. Batch Update Multiple Flows
```javascript
const updates = [
    { appId: 'app1', flowId: 'flow1', jsonFilePath: './flow1.json' },
    { appId: 'app1', flowId: 'flow2', jsonFilePath: './flow2.json' }
];

const results = await flowJsonManager.batchUpdateFlowJson(updates);
```

### 4. Template-Based Updates
```javascript
await advancedManager.updateFlowJsonWithTemplate(appId, flowId, 'welcome-flow', {
    title: 'Welcome Message',
    message: 'Hello there!'
});
```

## Important Notes

- **File Format**: Only JSON files are accepted
- **Size Limit**: Files must be under 10MB
- **Validation**: JSON must be valid and follow flow structure
- **Encoding**: Use UTF-8 encoding for JSON files
- **Backup**: Always backup existing flow JSON before updating
- **Testing**: Test flow JSON in development environment first
- **Version Control**: Implement version control for better management
- **Error Handling**: Implement proper error handling for production use
- **Monitoring**: Monitor flow JSON updates and validation errors
- **Structure**: Follow the required flow JSON structure and schema